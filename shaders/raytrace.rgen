#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable

#include "raycommon.glsl"
#include "wavefront.glsl"
#include "transform.glsl"
#include "random.glsl"

#define M_PI 3.1415926535897932384626433832795
#define M_INV_2PI 1.0 / (2 * M_PI)
#define M_HALF_PI M_PI / 2.0
#define E 2.7182818284590452353602874713527

#define MAT_DIFFUSE 0
#define MAT_SPECULAR 1
#define MAT_DIELECTRIC 2
#define MAT_LIGHT 3
#define MAT_PHONG 4
#define MAT_CONDUCTOR 5
#define MAT_ROUGH_CONDUCTOR 6

#define LIGHT_AREA 0
#define LIGHT_POINT_LIGHT 1
#define LIGHT_SPHERE 2
#define LIGHT_ENV_MAP 3

#define MAX_DISCRETE_FOLLOW 5

#define SIZE_LIGHT_RANDOM 10000
#define SIZE_TRI_RANDOM 10000


const float tMin = 0.0001;
const float tMax = 1000000.0;


const uint rayFlags = gl_RayFlagsNoneEXT;
const uint shadowRayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;


struct newIrradianceCacheInfo {
    vec3 origin;
    vec3 normal;
};

#define MAX_NEW_IRRADIANCE_ENTRIES 5
newIrradianceCacheInfo newIrradianceCacheEntries[MAX_NEW_IRRADIANCE_ENTRIES];
int nextNewIrradianceCacheSlot = 0;

//@formatter:off
layout(push_constant) uniform PushConstant{ pushConstant pushC; };

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;


layout(binding = 1, set = 1, std140) buffer Vertices{ Vertex v[]; } vertices[];
layout(binding = 2, set = 1) buffer Indices{ uint i[]; } indices[];
layout(binding = 3, set = 1, std430) buffer Materials{ Material mats[]; };
layout(binding = 4, set = 1, std140) buffer Instances{ InstanceInfo instanceInfos[]; };
layout(binding = 5, set = 1, std140) buffer LightsBuffer{ int lightCount; Light lights[]; };
layout(binding = 6, set = 1, std430) buffer LightSamplerBuffer{
    int randomLigthIndex[SIZE_LIGHT_RANDOM];
    FaceSample randomTriIndex[][SIZE_TRI_RANDOM];// access index is the one returned from randomLightIndex, as point lights come after area lights
};

layout(binding = 8, set = 1, std430) buffer Spheres { sphere spheres[]; };
layout(binding = 7, set = 1) uniform sampler2D textureSamplers[];
layout(binding = 9, set = 1, rgba32f) uniform image2D accumulateImage;
// Irradiance Cache
layout(binding = 10, set = 1, scalar) buffer Aabbs { aabb cacheAabbs[]; };
layout(binding = 11, set = 1) uniform accelerationStructureEXT irradianceAS;
layout(binding = 12, set = 1, std430) buffer CacheSpheres { sphere cacheSpheres[]; };
layout(binding = 13, set = 1, scalar) buffer Cache { cacheHeader header; cacheData cache[]; };

layout(binding = 0, set = 1)
uniform CameraMatrices{
    mat4 view;
    mat4 proj;
    mat4 viewInverse;
    mat4 projInverse;
} cam;

layout(location = 0) rayPayloadEXT hitInfo info;
layout(location = 1) rayPayloadEXT shadowCheck shadowInfo;
layout(location = 2) rayPayloadEXT hitInfo infoIrradiance;
layout(location = 3) rayPayloadEXT cacheHits cacheInfo;
//@formatter:on


// Rendering Vorlesung - Nori src/common.cpp
float fresnel(in float eta, in float cosThetaI) {
    float sinThetaSqr = eta * eta * (1 - cosThetaI * cosThetaI);

    if (sinThetaSqr > 1.0f) {
        return 1.0f;// Total internal reflection
    }

    float cosThetaT = sqrt(1.0f - sinThetaSqr);

    float Rs = (eta * cosThetaI - cosThetaT)
    / (eta * cosThetaI + cosThetaT);
    float Rp = (cosThetaI - eta * cosThetaT)
    / (cosThetaI + eta * cosThetaT);

    return (Rs * Rs + Rp * Rp) / 2.0f;
}

// Rendering Vorlesung - Nori src/common.cpp
float fresnelConductor(in float cosThetaI, in float eta, in float k) {
    if (cosThetaI < 0.0f) {
        cosThetaI = -cosThetaI;
    }

    // via http://web.cse.ohio-state.edu/~parent.1/classes/782/Lectures/05_Reflectance_Handout.pdf, slide "Fresnel Reflection - Conductor"
    float Rs2 = ((eta * eta + k * k) * cosThetaI * cosThetaI - 2 * eta * cosThetaI + 1)
    / ((eta * eta + k * k) * cosThetaI * cosThetaI + 2 * eta * cosThetaI + 1);
    float Rp2 = ((eta * eta + k * k) - 2 * eta * cosThetaI + cosThetaI * cosThetaI)
    / ((eta * eta + k * k) + 2 * eta * cosThetaI + cosThetaI * cosThetaI);

    return (Rs2 + Rp2) / 2.0f;
}


// Beckmann Distribution https://www.graphics.cornell.edu/~bjw/microfacetbsdf.pdf
float D(in Material mat, in vec3 n, in vec3 m) {
    float cosTheta = dot(n, m);

    if (cosTheta <= 0) {
        return 0.0;
    }

    float theta = acos(cosTheta);
    float thanTheta = tan(theta);

    float alphaSqr = (mat.roughness * mat.roughness);

    return pow(E, - thanTheta * thanTheta / alphaSqr) / (M_PI * alphaSqr * pow(cosTheta, 4));
}

float G1(in Material mat, in vec3 n, in vec3 m, in vec3 v) {
    float thetaV = dot(v, n);
    float c = dot(v, m) / thetaV;

    if (c <= 0) {
        return 0;
    }


    float a = 1.0 / (mat.roughness * tan(thetaV));

    if (a >= 1.6) {
        return 1.0;
    } else {
        float a2 = a * a;
        return (3.535 * a + 2.181 * a2)/(1 + 2.276 * a + 2.577 * a);
    }

}

float G(in Material mat, in vec3 i, in vec3 o, in vec3 n, in vec3 m) {
    return G1(mat, n, m, i) * G1(mat, n, m, o);
}

vec3 diffuse(in Material mat, in vec2 uv) {
    if (mat.textureIdDiffuse != -1) {
        return mat.diffuse * texture(textureSamplers[mat.textureIdDiffuse], info.textureUV).xyz /
        M_PI;
    } else {
        return mat.diffuse / M_PI;
    }
}

// Energy conserving phong method (Lewis ?)
vec3 phong(in Material mat, in vec2 uv, in vec3 normal, in vec3 wi, in vec3 wo) {
    vec3 res = vec3(0.0, 0.0, 0.0);

    float cosThetaWo = dot(wo, normal);
    if (cosThetaWo > 0) {
        if (mat.textureIdDiffuse != -1) {
            res += mat.diffuse * texture(textureSamplers[mat.textureIdDiffuse], info.textureUV).xyz /
            M_PI;
        } else {
            res += mat.diffuse / M_PI;
        }

        float dotReflDir = dot(reflect(-wo, normal), wi);
        if (dotReflDir > 0) {
            if (mat.textureIdSpecular != -1) {
                res += (mat.specularHighlight + 2) / (2 * M_PI) * mat.specular * pow(dotReflDir, mat.specularHighlight) *
                texture(textureSamplers[mat.textureIdSpecular], info.textureUV).xyz;
            } else {
                res += (mat.specularHighlight + 2) / (2 * M_PI) * mat.specular * pow(dotReflDir, mat.specularHighlight);
            }
        }

    }

    return cosThetaWo * res;
}

vec3 roughConductor(in Material mat, in vec3 normal, in vec3 wi, in vec3 wo) {
    vec3 hr = normalize(wi + wo);
    float cosThetaIHr = dot(wi, hr);
    float cosThetaI = dot(wi, normal);
    float cosThetaO = dot(wo, normal);

    return (fresnelConductor(cosThetaIHr, mat.eta, mat.k) * G(mat, wi, wo, normal, hr) * D(mat, normal, hr) / (4 * cosThetaI * cosThetaO)).xxx;
}



float pdfBSDF(in Material mat, in vec3 normal, in vec3 wi, in vec3 wo) {
    switch (mat.type) {
        case MAT_ROUGH_CONDUCTOR:
        vec3 hr = normalize(wi + wo);
        float pm = D(mat, normal, hr);

        if (pm == 0) {
            return 0.0;
        }

        return pm / (4 * dot(wo, hr));

        case MAT_PHONG:// Phong
        if (dot(normal, wo) < 0) {
            // Absorb rays below surface
            return 0.0;
        }

        float lDiffuse = length(mat.diffuse);
        float lSpecular = length(mat.specular);
        float sumSpecDiff = lDiffuse + lSpecular;

        // Completely black objects would produce NaN otherwise
        if (sumSpecDiff == 0) {
            return 0.0;
        }


        // Combine the probabilities of the two sampling methods
        // Cosine power/phong lobe
        vec3 reflected = reflect(-wi, normal);
        float highlight = mat.specularHighlight;

        float pdf = 0;
        if (dot(reflected, wo) > 0) {
            pdf = (highlight + 1) * pow(dot(reflected, wo), highlight) / (2 * M_PI);
            pdf *= lSpecular / sumSpecDiff;
        }

        // Cosine Hemisphere
        pdf += dot(wo, normal) / M_PI * lDiffuse / sumSpecDiff;

        return pdf;

        case MAT_DIFFUSE:// Cosine Hemisphere
        default :
        return dot(wo, normal) / M_PI;
    }
}

float pdfLight(in Light light, in vec3 lightDir, in vec3 lightNormal, in float lightDistance) {
    float cosThetaLight = dot(-lightDir, lightNormal);

    return light.sampleProb * lightDistance * lightDistance /
    cosThetaLight / light.area;
}

float powerHeuristic(in float pdf1, in float pdf2) {
    float sqr_p1 = pdf1 * pdf1;
    return sqr_p1 / (sqr_p1 + pdf2 * pdf2);
}

/**
 * Select a random light and a position on it
 * @param vec3
 * @param vec3
 * @param vec3
 * @param lightDistance
 * @return
 */
float sampleLights(in vec3 origin, in vec3 normal, out vec3 lightDir, out vec3 lightColor, out float lightDistance) {
    // Next event estimation
    // Sample random light

    int iRandomLight;
    int iLight;
    Light light;

    iRandomLight = getRandomInteger(SIZE_LIGHT_RANDOM - 1);

    iLight = randomLigthIndex[iRandomLight];
    light = lights[iLight];

    if (light.type == LIGHT_POINT_LIGHT) {
        // Point light
        vec3 toLight = light.pos - origin;
        lightDistance = length(toLight);
        lightDir = toLight / lightDistance;

        lightColor = light.color / (lightDistance * lightDistance);
        return light.sampleProb;
    } else if (light.type == LIGHT_SPHERE) {
        // Sphere
        sphere s = spheres[light.instanceIndex];

        lightColor = mats[s.materialIndex].lightColor;

        vec3 sphereNormal;
        float area;
        vec3 position;
        if (pushC.useVisibleSphereSampling) {
            // Only sample the visible side of the sphere
            // => only half of the light area
            area = light.area / 2.0;
            position = randomOnSphereVisible(s, normal, sphereNormal);
        } else {
            area = light.area;
            position = randomOnSphere(s, sphereNormal);
        }
        vec3 toLight = position - origin;

        lightDistance = length(toLight);
        lightDir = normalize(toLight);

        float cosThetaLight = dot(-lightDir, sphereNormal);

        return light.sampleProb * lightDistance * lightDistance /
        (cosThetaLight * area);
    } else if (light.type == LIGHT_ENV_MAP) {
        // Env Map
        lightDir = randomInHemisphere(normal);


        float atan = atan(lightDir.x, -lightDir.z);
        float u = atan * M_INV_2PI;
        float v = acos(lightDir.y) / M_PI;

        vec2 envMapUV = vec2(u, v);
        lightColor = texture(textureSamplers[0], envMapUV).xyz;
        lightDistance = tMax;

        float cosThetaLight = dot(-lightDir, normal);
        // TODO: PDF envmap
        return light.sampleProb * M_INV_2PI;
    } else {
        // Area light
        int iModel = instanceInfos[light.instanceIndex].modelIndex;

        int iRandomTri = getRandomInteger(SIZE_TRI_RANDOM - 1);
        FaceSample triSample = randomTriIndex[iLight][iRandomTri];

        int iTri = triSample.index;

        ivec3 ind = ivec3(indices[iModel].i[3 * iTri + 0], //
        indices[iModel].i[3 * iTri + 1], //
        indices[iModel].i[3 * iTri + 2]);//

        // Vertex of the triangle
        Vertex v0 = vertices[iModel].v[ind.x];
        Vertex v1 = vertices[iModel].v[ind.y];
        Vertex v2 = vertices[iModel].v[ind.z];

        // Uniform random point on triangle
        vec2 randomXY = vec2(rnd(), rnd());
        float sqrtx = sqrt(randomXY.x);
        float sqrty = sqrt(randomXY.y);
        vec3 barycentrics = vec3(1.0 - sqrtx, sqrtx * (1.0 - randomXY.y), randomXY.y * sqrtx);

        // Computing the coordinates of the hit position
        vec3 lightSampleWorldPos = v0.pos * barycentrics.x + v1.pos * barycentrics.y + v2.pos * barycentrics.z;
        vec3 lightSampleNormal = v0.normal * barycentrics.x + v1.normal * barycentrics.y + v2.normal * barycentrics.z;

        // Transforming the position and normal to world space
        mat4 transform = instanceInfos[light.instanceIndex].transform;
        mat4 normalTransform = instanceInfos[light.instanceIndex].normalTransform;
        lightSampleWorldPos = (transform * vec4(lightSampleWorldPos, 1.0)).xyz;
        lightSampleNormal = (normalTransform * vec4(lightSampleNormal, 0.0)).xyz;

        // Normalize normal, because scaling
        lightSampleNormal = normalize(lightSampleNormal);

        vec3 toLight = lightSampleWorldPos - origin;
        lightDistance = length(toLight);
        lightDir = toLight / lightDistance;

        lightColor = mats[v0.materialIndex].lightColor;

        float cosThetaLight = dot(-lightDir, lightSampleNormal);

        return light.sampleProb * lightDistance * lightDistance /
        cosThetaLight / light.area;
    }
}

/**
 *
 * @param Material
 * @param vec3
 * @param vec3
 * @param vec3
 * @return pdf
 */
float sampleBSDF(in Material mat, in vec3 direction, in vec3 normal, in bool frontFace, out vec3 newDirection) {
    switch (mat.type) {
        case MAT_ROUGH_CONDUCTOR:
        vec3 worldM = randomBeckmannNormal(mat, normal);

        newDirection = reflect(direction, worldM);

        return pdfBSDF(mat, normal, -direction, newDirection);

        case MAT_PHONG:
        float lDiffuse = length(mat.diffuse);
        float lSpecular = length(mat.specular);
        float sumSpecDiff = lDiffuse + lSpecular;

        // Completely black objects would produce NaN otherwise
        if (sumSpecDiff == 0) {
            return 0.0;
        }

        float pdf;
        if (rnd() * sumSpecDiff > lDiffuse) {
            // Cosine power/phong lobe
            vec3 reflected = reflect(direction, normal);

            float highlight = mat.specularHighlight;
            newDirection = randomInHemisphereCosinePower(reflected, highlight);

            if (dot(normal, newDirection) < 0) {
                // Absorb rays below surface
                return 0.0;
            }

            return pdfBSDF(mat, normal, -direction, newDirection);
        } else {
            // Cosine Hemisphere
            newDirection = randomInHemisphereCosine(normal);
            return pdfBSDF(mat, normal, -direction, newDirection);
        }


        case MAT_SPECULAR:
        case MAT_CONDUCTOR:
        newDirection = reflect(direction, normal);
        return 1.0;

        case MAT_DIELECTRIC:
        float eta = mat.refractionIndexInv;

        if (!frontFace) {
            eta = mat.refractionIndex;
        }
        float cosTheta = dot(-direction, normal);
        float fresnel = fresnel(eta, cosTheta);

        if (rnd() > fresnel) {
            // Refract
            newDirection = refract(direction, normal, eta);
            return 1.0 - fresnel;
        } else {
            // Reflect
            newDirection = reflect(direction, normal);
            return fresnel;
        }

        case MAT_DIFFUSE:
        default :
        // Cosine Hemisphere
        newDirection = randomInHemisphereCosine(normal);
        return dot(newDirection, normal) / M_PI;
    }
}

/**
 * For discrete direction material, assume that wo is one of the correct directions
 */
vec3 evalBsdf(Material mat, vec2 uv, vec3 normal, vec3 wi, vec3 wo, bool frontFace) {
    switch (mat.type) {
        case MAT_DIFFUSE:
        case MAT_LIGHT:
        return dot(wo, normal) * diffuse(mat, uv);
        case MAT_PHONG:
        return phong(mat, uv, normal, wi, wo);

        case MAT_ROUGH_CONDUCTOR:
        return roughConductor(mat, normal, wi, wo);

        case MAT_DIELECTRIC:
        {
            float cosTheta = dot(normal, wo);

            float eta = mat.refractionIndexInv;

            if (!frontFace) {
                eta = mat.refractionIndex;
            }

            if (cosTheta < 0) {
                // Refraction
                return mat.specular * (1 - fresnel(eta, cosTheta));
            } else {
                // Reflect
                return mat.specular * fresnel(eta, cosTheta);
            }
        }
        case MAT_CONDUCTOR:
        {
            float cosTheta = dot(wi, normal);
            return fresnelConductor(cosTheta, mat.eta, mat.k).xxx;
        }
        case MAT_SPECULAR:
        return mat.specular;

        default :
        return vec3(0, 0, 0);
    }
}

vec3 nextEventEstimation(Material mat, vec3 origin, vec3 direction, vec3 normal) {
    switch (mat.type) {
        case MAT_DIFFUSE:
        case MAT_PHONG:
        case MAT_LIGHT:
        case MAT_ROUGH_CONDUCTOR:
        break;
        default :
        // Only run NEE for those materials that are supported
        return vec3(0, 0, 0);
    }

    vec3 neeResult = vec3(0, 0, 0);

    // Sample random light
    vec3 lightDir;
    vec3 lightColor;
    float lightDistance;
    float pdfLights = sampleLights(origin, normal, lightDir, lightColor, lightDistance);

    vec2 textureUV = info.textureUV;

    // Check if shadowed
    shadowInfo.isShadowed = true;
    if (dot(lightDir, normal) > 0 && pdfLights > 0) {
        traceRayEXT(topLevelAS, // acceleration structure
        shadowRayFlags, // rayFlags
        0xFF, // cullMask
        0, // sbtRecordOffset
        0, // sbtRecordStride
        1, // missIndex of shadow miss
        origin.xyz, // ray origin
        tMin, // ray min range
        lightDir, // ray direction
        lightDistance * (1 - 0.0001), // ray max range
        1// payload (location = 1)
        );
    }

    if (!shadowInfo.isShadowed) {
        if (pushC.enableMIS) {
            // MIS
            float pdfMat = pdfBSDF(mat, normal, -direction, lightDir);
            neeResult += evalBsdf(mat, textureUV, normal, -direction, lightDir, info.isFrontFace) *
            lightColor * powerHeuristic(pdfLights, pdfMat) / pdfLights;
        } else {
            neeResult = evalBsdf(mat, textureUV, normal, -direction, lightDir, info.isFrontFace)
            * lightColor / pdfLights;
        }
    }

    if (pushC.enableMIS) {
        // Direct light check with BSDF sample
        vec3 bsdfDir;
        float pdfMat = sampleBSDF(mat, direction, normal, info.isFrontFace, bsdfDir);

        if (pdfMat > 0)  {
            traceRayEXT(topLevelAS, // acceleration structure
            rayFlags, // rayFlags
            0xFF, // cullMask
            0, // sbtRecordOffset
            0, // sbtRecordStride
            0, // missIndex
            origin.xyz, // ray origin
            tMin, // ray min range
            bsdfDir, // ray direction
            tMax, // ray max range
            0// payload (location = 0)
            );

            // Check if a light was hit at all
            Material matSample = mats[info.matIndex];
            if (!info.isMiss && matSample.type == 3) {
                int iLight = instanceInfos[info.instanceIndex].iLight;
                Light light = lights[iLight];

                lightColor = matSample.lightColor;
                pdfLights = pdfLight(light, bsdfDir, info.normal, info.t);

                neeResult += evalBsdf(mat, textureUV, normal, -direction, bsdfDir, info.isFrontFace) *
                lightColor * powerHeuristic(pdfMat, pdfLights) / pdfMat;
            }


        }
    }
    return neeResult;
}

bool hasDiscreteDirection(Material mat) {
    switch (mat.type) {
        case MAT_DIELECTRIC:
        case MAT_SPECULAR:
        case MAT_CONDUCTOR:
        return true;
        default :
        return false;
    }
}

bool queryIrradianceCache(vec3 origin, vec3 normal, out vec3 color);

vec3 multipleNEE(Material mat, vec3 origin, vec3 direction, vec3 normal, int numNEE) {
    vec3 result = vec3(0, 0, 0);
    for (int i = 0; i < numNEE; i++) {
        result += nextEventEstimation(mat, origin, direction, normal);
    }
    return result / numNEE;
}

vec3 raytrace(vec3 origin, vec3 direction, int maxDepth, int maxFollowDiscrete, bool addDirectLights, bool useNEE, int numNEE, bool useIC, bool createIC, out float firstT) {
    bool follow = true;
    int followCount = 0;
    bool addNextDirectLights = false;
    float r = tMax;
    int depth = 0;
    vec3 normal;
    firstT = tMax;

    vec3 throughput = vec3(1.0, 1.0, 1.0);
    vec3 result = vec3(0.0, 0.0, 0.0);

    do {
        depth++;

        traceRayEXT(topLevelAS, // acceleration structure
        rayFlags, // rayFlags
        0xFF, // cullMask
        0, // sbtRecordOffset
        0, // sbtRecordStride
        0, // missIndex
        origin.xyz, // ray origin
        tMin, // ray min range
        direction.xyz, // ray direction
        tMax, // ray max range
        0// payload (location = 0)
        );


        if (info.isMiss) {
            if (addDirectLights || addNextDirectLights) {
                result += throughput * info.missColor;
            }
            break;
        }

        // Get hit properties
        Material mat = mats[info.matIndex];
        origin = info.worldPos;
        normal = info.normal;

        // For average distance calculation
        if (depth == 1) {
            firstT = info.t;
        }

        // Light hit
        if (mat.type == MAT_LIGHT && (addDirectLights || addNextDirectLights)) {
            result += throughput * mat.lightColor;
        }

        if (hasDiscreteDirection(mat)) {
            // The next direct light hit has to contribute, as mirrors would be black otherwise
            addNextDirectLights = true;

            // When there is a discrete direction, NEE is not possible and we should continue on, even if depth > maxDepth
            follow = true;
            if (depth >= maxDepth) {
                followCount++;
            }
        } else {
            addNextDirectLights = false;
            follow = false;

            if (useNEE) {
                result += throughput * multipleNEE(mat, origin, direction, normal, numNEE);
            }

            if (useIC) {
                // If diffuse, then check if irradiance cache is nearby
                vec3 irradianceColor;
                if (mat.type == MAT_DIFFUSE) {
                    if (queryIrradianceCache(origin, normal, irradianceColor)) {
                        // Record found -> use it
                        result += throughput * diffuse(mat, info.textureUV) * irradianceColor;

                        // If IC values are used, then NEE is necessary for the complete light values
                        if (!useNEE) {
                            result += throughput * multipleNEE(mat, origin, direction, normal, numNEE);
                        }

                        break;
                    } else if (createIC && rnd() < pushC.irradianceCreateProb) {
                        // No record found -> create one
                        // All irradiance cache values are only available in the next frame,
                        // Therefore we need to limit the amount of cache entries created, as otherwise all rays would create one

                        if (nextNewIrradianceCacheSlot < MAX_NEW_IRRADIANCE_ENTRIES) {
                            newIrradianceCacheInfo newCacheInfo;
                            newCacheInfo.origin = origin;
                            newCacheInfo.normal = normal;

                            newIrradianceCacheEntries[nextNewIrradianceCacheSlot] = newCacheInfo;
                            nextNewIrradianceCacheSlot++;
                        }
                    }
                }
            }
        }

        vec3 newDirection;
        float pdf = sampleBSDF(mat, direction, normal, info.isFrontFace, newDirection);

        if (pdf <= 0.0) {
            break;
        }
        throughput *= evalBsdf(mat, info.textureUV, normal, -direction, newDirection, info.isFrontFace) / pdf;

        direction = newDirection;
    } while (depth <= maxDepth || (follow && followCount <= maxFollowDiscrete));

    return result;
}

/**
* returns true if cache hits found
*/
bool queryIrradianceCache(vec3 origin, vec3 normal, out vec3 color) {
    cacheInfo.origin = origin;
    cacheInfo.normal = normal;
    cacheInfo.cacheValueSum = vec3(0, 0, 0);
    cacheInfo.totalWeight = 0;

    traceRayEXT(irradianceAS, // acceleration structure
    gl_RayFlagsSkipClosestHitShaderEXT, // rayFlags
    0xFF, // cullMask
    0, // sbtRecordOffset
    0, // sbtRecordStride
    0, // missIndex
    origin.xyz, // ray origin
    0, // ray min range
    normal.xyz, // ray direction
    tMin, // ray max range
    3// payload (location = 3)
    );

    if (cacheInfo.totalWeight > 0) {
        color = cacheInfo.cacheValueSum / cacheInfo.totalWeight;
        return true;
    }

    return false;
}

/**
* returns the harmonicR
*/
float calculateCacheData(in vec3 origin, in vec3 normal, out vec3 calculatedColor, out vec3 rotGrad, out vec3 transGrad) {
    const int N = 20;
    const int M = 10;

    float invDistanceSum = 0;
    int numDistances = 0;
    int maxFollowDiscrete = 10;
    bool createIC = true;
    const bool addDirectLights = false;


    vec3 hitNormal, hitOrigin;

    rotGrad = vec3(0, 0, 0);
    transGrad = vec3(0, 0, 0);
    vec3 color = vec3(0, 0, 0);
    for (int k = 0; k < N; k++) {
        float phi = 2 * M_PI * (k + rnd()) / N;

        vec3 uk = toWorld(sphericalToCartesian(M_HALF_PI, phi), normal);
        vec3 vk = toWorld(sphericalToCartesian(M_HALF_PI, phi + M_HALF_PI), normal);
        vec3 previousVk = toWorld(sphericalToCartesian(M_HALF_PI, 2 * M_PI * k / N + M_HALF_PI), normal);
        float previousKLs[N];
        float previousKRs[N];
        float previousJR;
        float previousJL;
        for (int j = 0; j < M; j++) {
            float theta = asin(sqrt((j + rnd()) / M));

            vec3 direction = toWorld(sphericalToCartesian(theta, phi), normal);

            float r = tMax;

            vec3 sampleColor = raytrace(origin, direction, 1, maxFollowDiscrete, addDirectLights, true, pushC.irradianceNumNEE, true, createIC, r);
            color += sampleColor;

            if (r < tMax) {
                invDistanceSum += 1.0 / r;
                numDistances++;
            }

            float L = length(sampleColor);
            float previousJTheta = asin(sqrt(j / float(M)));
            float nextJTheta = asin(sqrt((j + 1) / float(M)));

            // Rotation gradient
            rotGrad += -tan(theta) * L * vk;

            // Translational gradient
            if (j > 0) {
                float cosPreviousTheta = cos(previousJTheta);
                transGrad  += uk * 2 * M_PI / N * sin(previousJTheta) * cosPreviousTheta * cosPreviousTheta / min(r, previousJR) * (L - previousJL);
            }

            if (k > 0) {
                transGrad += previousVk  * (sin(nextJTheta) - sin(previousJTheta)) / min(r, previousKRs[j]) * (L - previousKLs[j]);
            }

            previousKLs[j] = L;
            previousKRs[j] = r;
            previousJL = L;
            previousJR = r;
        }
    }

    float normFactor = M_PI / (M * N);
    calculatedColor = normFactor * color;
    rotGrad *= normFactor;



    float harmonicR;
    if (invDistanceSum == 0 || numDistances == 0) {
        // No hit => no light
        return -1;
    } else {
        harmonicR = 1.0 / (invDistanceSum / numDistances);
    }

    return harmonicR;
}

/**
* Updates color and radius of cache entry
*/
void updateIrradianceCache() {
    uint cacheIndex = atomicAdd(header.nextUpdateSlot, 1);
    if (cacheIndex >= header.nextCacheSlot) {
        header.nextUpdateSlot = 0;
        return;
    }

    // unititialized
    if (cache[cacheIndex].numUpdates < 1) {
        return;
    }

    vec3 rotGrad;
    vec3 transGrad;
    vec3 calculatedColor;
    float harmonicR = calculateCacheData(cacheSpheres[cacheIndex].center, cache[cacheIndex].normal, calculatedColor, rotGrad, transGrad);

    uint numUpdates = cache[cacheIndex].numUpdates;

    float a = min(numUpdates / float(numUpdates + 1), 0.95);

    cache[cacheIndex].color = mix(calculatedColor, cache[cacheIndex].color, a);
    cache[cacheIndex].rotGrad = mix(rotGrad, cache[cacheIndex].rotGrad, a);
    cache[cacheIndex].transGrad = mix(transGrad, cache[cacheIndex].transGrad, a);

    float radius;
    if (harmonicR > 0) {
        // harmonicR only gets updated if at least one object hit in hemisphere
        harmonicR = mix(harmonicR, cache[cacheIndex].harmonicR, a);
    } else {
        harmonicR = cache[cacheIndex].harmonicR;
    }

    // Lower bound for radius to prevent unlimited number of IC entries in corners
    harmonicR = max(harmonicR, pushC.irradianceCacheMinRadius);
    cache[cacheIndex].harmonicR = harmonicR;

    radius = pushC.irradianceA * harmonicR;

    cacheSpheres[cacheIndex].radius = radius;
    cacheAabbs[cacheIndex].min = cacheSpheres[cacheIndex].center - radius.xxx;
    cacheAabbs[cacheIndex].max = cacheSpheres[cacheIndex].center + radius.xxx;
    cache[cacheIndex].numUpdates += 1;
}

bool createIrradianceCache(vec3 origin, vec3 normal, out vec3 calculatedColor) {
    if (header.nextCacheSlot > header.maxCaches) {
        return false;
    }
    vec3 rotGrad;
    vec3 transGrad;
    float harmonicR = calculateCacheData(origin, normal, calculatedColor, rotGrad, transGrad);

    if (harmonicR < 0) {
        return false;
    }

    uint cacheIndex = atomicAdd(header.nextCacheSlot, 1);

    if (cacheIndex > header.maxCaches) {
        return false;
    }

    // Lower bound for radius to prevent unlimited number of IC entries in corners
    harmonicR = max(harmonicR, pushC.irradianceCacheMinRadius);

    cache[cacheIndex].normal = normal;
    cache[cacheIndex].color = calculatedColor;
    cache[cacheIndex].harmonicR = harmonicR;
    cache[cacheIndex].rotGrad = rotGrad;
    cache[cacheIndex].transGrad = transGrad;
    cache[cacheIndex].numUpdates = 1;

    cacheSpheres[cacheIndex].center = origin;

    float radius = pushC.irradianceA * harmonicR;
    cacheSpheres[cacheIndex].radius = pushC.irradianceA * harmonicR;
    cacheAabbs[cacheIndex].min = origin - radius.xxx;
    cacheAabbs[cacheIndex].max = origin + radius.xxx;

    return true;
}

vec3 visualizeIC(vec3 origin, vec3 direction) {
    traceRayEXT(topLevelAS, // acceleration structure
    rayFlags, // rayFlags
    0xFF, // cullMask
    0, // sbtRecordOffset
    0, // sbtRecordStride
    0, // missIndex
    origin.xyz, // ray origin
    tMin, // ray min range
    direction.xyz, // ray direction
    tMax, // ray max range
    0// payload (location = 0)
    );

    if (info.isMiss) {
        return info.missColor;
    }

    vec3 icColor;
    if (queryIrradianceCache(info.worldPos, info.normal, icColor)) {
        if (pushC.highlightIrradianceCacheColor) {
            icColor -= min(min(icColor.r, icColor.g), icColor.b).xxx;
        }

        return pushC.irradianceVisualizationScale * icColor;
    }
    return vec3(0, 0, 0);
}

void main() {
    // Init seed
    seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pushC.randomUInt);

    vec3 result = vec3(0.0, 0.0, 0.0);

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);

    if (pushC.useIrradianceCache && rnd() < pushC.irradianceUpdateProb) {
        updateIrradianceCache();
    }

    // Prepare frames should only have one sample per pixel
    const int samplesPerPixel = pushC.isIrradiancePrepareFrame ? 1 : pushC.samplesPerPixel;
    const int maxDepth = pushC.maxDepth;
    const int maxFollowDiscrete = 3;
    const bool useNEE = pushC.enableNEE;
    const bool addDirectLights = !useNEE;
    const int numNEE = 1;

    const bool useIC = pushC.useIrradianceCache;

    for (int iSample = 0; iSample < samplesPerPixel; ++iSample) {
        vec2 inUV = (pixelCenter + vec2(getRandomNegPos(), getRandomNegPos()) / 2.0) / vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;

        vec3 origin = (cam.viewInverse * vec4(0, 0, 0, 1)).xyz;
        vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1);
        vec3 direction = normalize((cam.viewInverse * vec4(normalize(target.xyz), 0)).xyz);

        float firstT;
        if (pushC.showIrradianceCacheOnly) {
            result += visualizeIC(origin, direction);
        } else {
            result += raytrace(origin, direction, maxDepth, maxFollowDiscrete, addDirectLights, useNEE, numNEE, useIC, true, firstT);
        }
    }

    result /= samplesPerPixel;

    ivec2 imageUV = ivec2(gl_LaunchIDEXT.xy);

    if (pushC.enableAverageInsteadOfMix) {
        // if the camera hasn't changed, then accumulate results
        if (pushC.previousFrames > 0) {
            vec3 accumulated = imageLoad(accumulateImage, imageUV).xyz;
            accumulated += result;

            imageStore(image, imageUV, vec4(accumulated / (pushC.previousFrames + 1), 1.0));
            imageStore(accumulateImage, imageUV, vec4(accumulated, 1.0));
        } else {
            imageStore(accumulateImage, imageUV, vec4(result, 1.0));
            imageStore(image, imageUV, vec4(result, 1.0));
        }
    } else {
        // if the camera hasn't changed, then mix with previous results
        if (pushC.previousFrames > 0) {
            vec3 previous = imageLoad(image, imageUV).xyz;
            result = mix(previous, result, 1.0 / (pushC.previousFrames + 1));

            imageStore(image, imageUV, vec4(result, 1.0));
        } else {
            imageStore(image, imageUV, vec4(result, 1.0));
        }
    }


    // Create IC entries
    for (int i = 0; i < nextNewIrradianceCacheSlot; i++) {
        newIrradianceCacheInfo newCacheInfo = newIrradianceCacheEntries[i];

        vec3 color;
        createIrradianceCache(newCacheInfo.origin, newCacheInfo.normal, color);
    }
}