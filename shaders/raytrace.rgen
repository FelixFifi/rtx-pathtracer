#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#include "raycommon.glsl"
#include "wavefront.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;

layout(binding = 3, set = 1, std430) buffer Materials { Material mats[]; };
layout(binding = 4, set = 1) uniform sampler2D noiseSampler;

layout(push_constant) uniform PushConstant { pushConstant pushC; };

layout(binding = 0, set = 1) uniform CameraMatrices {
        mat4 view;
        mat4 proj;
        mat4 viewInverse;
        mat4 projInverse;
} cam;

layout(location = 0) rayPayloadEXT hitInfo info;

vec2 noiseUV;
const vec2 noiseStride = vec2(0.01111, 0.02222);
const float NUM_SAMPLES = 1.0;

// https://math.stackexchange.com/a/1163278
vec3 randomOnUnitSphere() {
    vec3 res;
    do {
        vec4 random = texture(noiseSampler, noiseUV);
        noiseUV += noiseStride;

        res = random.xyz;

    } while (length(res) > 1);

    res = normalize(res);
    return res;
}

void main()
{
    vec3 result = vec3(0.0, 0.0, 0.0);


    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    noiseUV = inUV + pushC.previousFrames * noiseStride;

    const uint  rayFlags = gl_RayFlagsOpaqueEXT;
    const float tMin     = 0.001;
    const float tMax     = 10000.0;

    for (int iSample = 0; iSample < NUM_SAMPLES; ++iSample) {
        vec3 sampleResult = vec3(0.0, 0.0, 0.0);
        vec3 attenuation = vec3(1.0, 1.0, 1.0);


        vec3 origin    = (cam.viewInverse * vec4(0, 0, 0, 1)).xyz;
        vec4 target    = cam.projInverse * vec4(d.x, d.y, 1, 1);
        vec3 direction = (cam.viewInverse * vec4(normalize(target.xyz), 0)).xyz;

        for (int iDepth = 0; iDepth < pushC.maxRecursion; ++iDepth) {
            traceRayEXT(topLevelAS,     // acceleration structure
                        rayFlags,       // rayFlags
                        0xFF,           // cullMask
                        0,              // sbtRecordOffset
                        0,              // sbtRecordStride
                        0,              // missIndex
                        origin.xyz,     // ray origin
                        tMin,           // ray min range
                        direction.xyz,  // ray direction
                        tMax,           // ray max range
                        0               // payload (location = 0)
            );

            if (info.isLight) {
                sampleResult += attenuation * info.lightColor;
                break;
            }

            origin = info.worldPos;

            Material mat = mats[info.matIndex];

            switch (mat.type) {
                case 0: // Diffuse
                    attenuation *= mat.diffuse;

                    direction = info.normal + randomOnUnitSphere();
                    direction = normalize(direction);

                    break;
                case 1: // Specular
                {
                    attenuation *= mat.specular;

                    direction = reflect(direction, info.normal);
                    break;
                }

                case 2: // Transparent
                {
                    direction = direction;

                    break;
                }
            }
        }

        result += sampleResult / NUM_SAMPLES;
    }

    ivec2 imageUV = ivec2(gl_LaunchIDEXT.xy);

    // if the camera hasn't changed, then accumulate results
    if (pushC.previousFrames > 0) {
        vec4 previous = imageLoad(image, imageUV);
        vec4 combined = mix(previous, vec4(result, 1.0), 1.0f / (pushC.previousFrames + 1));
        imageStore(image, imageUV, combined);
    } else {
        imageStore(image, imageUV, vec4(result, 1.0));
    }
}