#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#include "raycommon.glsl"
#include "wavefront.glsl"
#define M_PI 3.1415926535897932384626433832795
#define SIZE_LIGHT_RANDOM 10000
#define SIZE_TRI_RANDOM 10000

layout(push_constant) uniform PushConstant { pushConstant pushC; };

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;


layout(binding = 1, set = 1, std140) buffer Vertices { Vertex v[]; } vertices[];
layout(binding = 2, set = 1) buffer Indices { uint i[]; } indices[];
layout(binding = 3, set = 1, std430) buffer Materials { Material mats[]; };
layout(binding = 4, set = 1, std140) buffer Instances { InstanceInfo instanceInfos[]; };
layout(binding = 5, set = 1, std140) buffer LightsBuffer { int lightCount; Light lights[]; };
layout(binding = 6, set = 1, std430) buffer LightSamplerBuffer {
    int randomLigthIndex[SIZE_LIGHT_RANDOM];
    FaceSample randomTriIndex[][SIZE_TRI_RANDOM]; // access index is the one returned from randomLightIndex, as point lights come after area lights
};
layout(binding = 7, set = 1) uniform sampler2D noiseSampler;


layout(binding = 0, set = 1) uniform CameraMatrices {
        mat4 view;
        mat4 proj;
        mat4 viewInverse;
        mat4 projInverse;
} cam;

layout(location = 0) rayPayloadEXT hitInfo info;
layout(location = 1) rayPayloadEXT shadowCheck shadowInfo;

vec2 noiseUV;
const vec2 noiseStride = vec2(0.0129898, 0.078233);

// Random vec4 [-1, 1)
vec4 getRandom() {
    vec4 res = texture(noiseSampler, noiseUV);
    noiseUV += noiseStride;
    return res;
}

// Random vec4 [0, 1)
vec4 getRandomPositive() {
    return (getRandom() + 1.0) / 2.0;
}

// Random int [0, max]
int getRandomInteger(int max) {
    return int(floor(getRandomPositive().x * (max + 1)));
}

// https://math.stackexchange.com/a/1163278
vec3 randomOnUnitSphere() {
    vec3 res;
    do {
        vec4 random = getRandom();

        res = random.xyz;

    } while (length(res) > 1);

    res = normalize(res);
    return res;
}

vec3 randomInHemisphere(vec3 normal) {
    vec3 res;
    do {
        vec4 random = getRandom();

        res = random.xyz;
    } while (length(res) > 1);

    res = normalize(res);

    if (dot(normal, res) < 0) {
        res = res - normal * 2 * dot(normal, res);
    }
    return res;
}

// Rendering Vorlesung - Nori src/common.cpp
float fresnel(in float eta, in float cosThetaI) {
    float sinThetaSqr = eta * eta * (1- cosThetaI * cosThetaI);

    if (sinThetaSqr > 1.0f) {
        return 1.0f; // Total internal reflection
    }

    float cosThetaT = sqrt(1.0f - sinThetaSqr);

    float Rs = (eta * cosThetaI - cosThetaT)
               / (eta * cosThetaI + cosThetaT);
    float Rp = (cosThetaI - eta * cosThetaT)
               / (cosThetaI + eta * cosThetaT);

    return (Rs * Rs + Rp * Rp) / 2.0f;
}

void main()
{
    vec3 result = vec3(0.0, 0.0, 0.0);


    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);

    noiseUV = pixelCenter / gl_LaunchSizeEXT.xy + pushC.uvOffset;

    const uint  rayFlags = gl_RayFlagsOpaqueEXT;
    const uint  shadowRayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;
    const float tMin     = 0.001;
    const float tMax     = 10000.0;


    const int samplesPerPixel = pushC.samplesPerPixel;
    const int maxDepth = pushC.maxDepth;

    for (int iSample = 0; iSample < samplesPerPixel; ++iSample) {
        vec3 sampleResult = vec3(0.0, 0.0, 0.0);
        vec3 attenuation = vec3(1.0, 1.0, 1.0);

        vec2 inUV = (pixelCenter + getRandom().xy / 2.0) / vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;

        vec3 origin    = (cam.viewInverse * vec4(0, 0, 0, 1)).xyz;
        vec4 target    = cam.projInverse * vec4(d.x, d.y, 1, 1);
        vec3 direction = (cam.viewInverse * vec4(normalize(target.xyz), 0)).xyz;

        bool addDirectLightHits = true;

        for (int iDepth = 0; iDepth < maxDepth; ++iDepth) {
            traceRayEXT(topLevelAS,     // acceleration structure
                        rayFlags,       // rayFlags
                        0xFF,           // cullMask
                        0,              // sbtRecordOffset
                        0,              // sbtRecordStride
                        0,              // missIndex
                        origin.xyz,     // ray origin
                        tMin,           // ray min range
                        direction.xyz,  // ray direction
                        tMax,           // ray max range
                        0               // payload (location = 0)
            );

            // Directional light / skybox
            if (info.isLight) {
                sampleResult += attenuation * info.lightColor;
                break;
            }

            origin = info.worldPos;

            bool frontFace = true;
            if (dot(direction, info.normal) > 0.0) {
                info.normal = -info.normal;
                frontFace = false;
            }

            float cosTheta = dot(-info.normal, direction);

            Material mat = mats[info.matIndex];

            switch (mat.type) {
                case 3: // Light
                    if (!pushC.enableNEE || addDirectLightHits) {
                        sampleResult += attenuation * mat.lightColor;
                    }
                    // Then continue as diffuse
                case 0: // Diffuse
                    if (pushC.enableNEE && lightCount > 0) {
                        // factor 1/2 because of next event estimation
                        attenuation *= mat.diffuse * cosTheta * M_PI;

                        // Next event estimation
                        // Sample random light

                        int iRandomLight = getRandomInteger(SIZE_LIGHT_RANDOM - 1);
                        int iLight = randomLigthIndex[iRandomLight];
                        Light light = lights[iLight];

                        vec3 lightColor;
                        vec3 shadowDir;
                        float lightDistance;
                        float p;
                        if (light.isPointLight) {
                            vec3 toLight = light.pos - origin;
                            lightDistance = length(toLight);
                            shadowDir = normalize(toLight);

                            p = light.sampleProb;
                            lightColor = light.color / (lightDistance * lightDistance);
                        } else {
                            int iModel = instanceInfos[light.instanceIndex].modelIndex;
                            mat4 transform = instanceInfos[light.instanceIndex].transform;

                            int iRandomTri = getRandomInteger(SIZE_TRI_RANDOM - 1);
                            FaceSample triSample = randomTriIndex[iLight][iRandomTri];

                            int iTri = triSample.index;

                            p = light.sampleProb * triSample.sampleProb;

                            ivec3 ind = ivec3(indices[iModel].i[3 * iTri + 0],   //
                                              indices[iModel].i[3 * iTri + 1],   //
                                              indices[iModel].i[3 * iTri + 2]);  //

                            // Vertex of the triangle
                            Vertex v0 = vertices[iModel].v[ind.x];
                            Vertex v1 = vertices[iModel].v[ind.y];
                            Vertex v2 = vertices[iModel].v[ind.z];

                            // Uniform random point on triangle
                            vec2 random = getRandomPositive().xy;
                            float sqrtx = sqrt(random.x);
                            float sqrty = sqrt(random.y);
                            vec3 barycentrics = vec3(1.0 - sqrtx, sqrtx * (1.0 - random.y), random.y * sqrtx);

                            // Computing the coordinates of the hit position
                            vec3 lightSampleWorldPos = v0.pos * barycentrics.x + v1.pos * barycentrics.y + v2.pos * barycentrics.z;
                            // Transforming the position to world space
                            lightSampleWorldPos = (transform * vec4(lightSampleWorldPos, 1.0)).xyz;

                            lightColor = mats[v0.materialIndex].lightColor;

                            vec3 toLight = lightSampleWorldPos - origin;
                            lightDistance = length(toLight) - 0.0001;
                            shadowDir = normalize(toLight);
                        }

                        shadowInfo.isShadowed = true;
                        if (dot(shadowDir, info.normal) > 0) {
                            traceRayEXT(topLevelAS,     // acceleration structure
                                        shadowRayFlags,       // rayFlags
                                        0xFF,           // cullMask
                                        0,              // sbtRecordOffset
                                        0,              // sbtRecordStride
                                        1,              // missIndex of shadow miss
                                        origin.xyz,     // ray origin
                                        tMin,           // ray min range
                                        shadowDir,  // ray direction
                                        lightDistance - 0.0001,           // ray max range
                                        1               // payload (location = 1)
                            );
                        }

                        if (!shadowInfo.isShadowed) {
                            sampleResult += attenuation * lightColor / p / (lightDistance * lightDistance);
                        }
                    } else {
                        attenuation *= mat.diffuse * cosTheta * 2.0 * M_PI;
                    }

                    direction = randomInHemisphere(info.normal);
                    addDirectLightHits = false;
                    break;
                case 1: // Specular
                {
                    attenuation *= mat.specular;

                    direction = reflect(direction, info.normal);
                    addDirectLightHits = true;
                    break;
                }

                case 2: // Transparent
                {
                    attenuation *= mat.specular;

                    float eta = mat.refractionIndexInv;

                    if (!frontFace) {
                        eta = mat.refractionIndex;
                    }
                    float cosTheta = dot(-direction, info.normal);
                    float fresnel = fresnel(eta, cosTheta);

                    if (getRandomPositive().x > fresnel) {
                        // Refract
                        direction = refract(direction, info.normal, eta);
                    } else {
                        // Reflect
                        direction = reflect(direction, info.normal);
                    }

                    addDirectLightHits = true;
                    break;
                }
            }

            if (pushC.enableRR) {
                float p = max(attenuation.x, max(attenuation.y, attenuation.z));
                // Russian roulette
                if (getRandomPositive().x > p) {
                    break;
                } else {
                    attenuation *= 1.0 / p;
                }
            }
        }

        result += sampleResult / samplesPerPixel;
    }

    ivec2 imageUV = ivec2(gl_LaunchIDEXT.xy);

    // if the camera hasn't changed, then accumulate results
    if (pushC.previousFrames > 0) {
        vec4 previous = imageLoad(image, imageUV);
        vec4 combined = mix(previous, vec4(result, 1.0), 1.0f / (pushC.previousFrames + 1));
        imageStore(image, imageUV, combined);
    } else {
        imageStore(image, imageUV, vec4(result, 1.0));
    }
}