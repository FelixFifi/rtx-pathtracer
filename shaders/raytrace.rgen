#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable

#include "limits.glsl"
#include "raycommon.glsl"
#include "wavefront.glsl"
#include "transform.glsl"
#include "guiding.glsl"
#include "random.glsl"
#include "guiding.visu.glsl"

#define M_PI 3.1415926535897932384626433832795
#define M_INV_PI 1.0 / M_PI
#define M_INV_2PI 1.0 / (2 * M_PI)
#define M_HALF_PI M_PI / 2.0
#define E 2.7182818284590452353602874713527

#define MAT_DIFFUSE 0
#define MAT_SPECULAR 1
#define MAT_DIELECTRIC 2
#define MAT_LIGHT 3
#define MAT_PHONG 4
#define MAT_CONDUCTOR 5
#define MAT_ROUGH_CONDUCTOR 6

#define LIGHT_AREA 0
#define LIGHT_POINT_LIGHT 1
#define LIGHT_SPHERE 2
#define LIGHT_ENV_MAP 3

#define VISU_RAYTRACE 0
#define VISU_DEPTH_MAX 1
#define VISU_DEPTH_AVERAGE 2
#define VISU_SPLITS 3
#define VISU_ESTIMATE 4
#define VISU_GUIDING_REGIONS 5
#define VISU_GUIDING_OVERLAY 6
#define VISU_GUIDING_ACTIVE_COMPONENTS 7
#define VISU_GUIDING_PIP 8

#define PAYLOAD_HIT 0
#define PAYLOAD_SHADOW 1
#define PAYLOAD_IC 2
#define PAYLOAD_GUIDING 3
#define PAYLOAD_GUIDING_VISU 4

#define VISU_HITGROUP_OFFSET 1

const float tMin = 0.001;
const float tMax = 1000000.0;


const uint rayFlags = gl_RayFlagsNoneEXT;
const uint shadowRayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;


struct newIrradianceCacheInfo {
    vec3 origin;
    vec3 normal;
};

#define MAX_NEW_IRRADIANCE_ENTRIES 5
newIrradianceCacheInfo newIrradianceCacheEntries[MAX_NEW_IRRADIANCE_ENTRIES];
int nextNewIrradianceCacheSlot = 0;

// Store ray splits
struct splitInfo {
    vec3 origin;
    vec3 normal;
    vec3 wi;
    vec3 throughput;
    vec2 textureUV;
    int matIndex;
    int currentDepth;
    bool isFrontFace;
};

// Queue with fixed max length
#define MAX_SPLITS 10
splitInfo splits[MAX_SPLITS];
int nextSplitSlot = 0;

// ADRRS
vec3 estimate;
float lengthEstimate;

// Guiding samples
vec3 sampleThroughputs[MAX_DIRECTIONAL_DATA_PER_PIXEL];
vec3 lightSums[MAX_DIRECTIONAL_DATA_PER_PIXEL];
int sampleOffset = 0;

//@formatter:off
layout(push_constant) uniform PushConstant{ pushConstant pushC; };

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;


layout(binding = 1, set = 1, std140) buffer Vertices{ Vertex v[]; } vertices[];
layout(binding = 2, set = 1) buffer Indices{ uint i[]; } indices[];
layout(binding = 3, set = 1, std430) buffer Materials{ Material mats[]; };
layout(binding = 4, set = 1, std140) buffer Instances{ InstanceInfo instanceInfos[]; };
layout(binding = 5, set = 1, scalar) buffer LightsBuffer{ int lightCount; Light lights[]; };
layout(binding = 6, set = 1, std430) buffer LightSamplerBuffer{
    int randomLigthIndex[SIZE_LIGHT_RANDOM];
    FaceSample randomTriIndex[][SIZE_TRI_RANDOM];// access index is the one returned from randomLightIndex, as point lights come after area lights
};

layout(binding = 8, set = 1, scalar) buffer Spheres { sphere spheres[]; };
layout(binding = 7, set = 1) uniform sampler2D textureSamplers[];
layout(binding = 9, set = 1, rgba32f) uniform image2D accumulateImage;
// Irradiance Cache
layout(binding = 10, set = 1, scalar) buffer Aabbs { aabb cacheAabbs[]; };
layout(binding = 11, set = 1) uniform accelerationStructureEXT irradianceAS;
layout(binding = 12, set = 1, scalar) buffer CacheSpheres { sphere cacheSpheres[]; };
layout(binding = 13, set = 1, scalar) buffer Cache { cacheHeader header; cacheData cache[]; };
layout(binding = 14, set = 1, rgba32f) uniform image2D estimateImage;
// Guiding
layout(binding = 15, set = 1, scalar) buffer GuidingAabbs { aabb guidingAabbs[]; };
layout(binding = 16, set = 1, scalar) buffer Guiding { VMM_Theta guidingVMM[]; };
layout(binding = 17, set = 1) uniform accelerationStructureEXT guidingAS;
layout(binding = 18, set = 1, scalar) buffer SampleCollector { DirectionalData directionalData[]; };


layout(binding = 0, set = 1)
uniform CameraMatrices{
    mat4 view;
    mat4 proj;
    mat4 viewInverse;
    mat4 projInverse;
} cam;

layout(location = PAYLOAD_HIT) rayPayloadEXT hitInfo info;
layout(location = PAYLOAD_SHADOW) rayPayloadEXT shadowCheck shadowInfo;
layout(location = PAYLOAD_IC) rayPayloadEXT cacheHits cacheInfo;
layout(location = PAYLOAD_GUIDING) rayPayloadEXT guidingInfo guidingInfos;
layout(location = PAYLOAD_GUIDING_VISU) rayPayloadEXT guidingVisuInfo guidingVisuInfos;
//@formatter:on


// Rendering Vorlesung - Nori src/common.cpp
float fresnel(in float eta, in float cosThetaI) {
    float sinThetaSqr = eta * eta * (1 - cosThetaI * cosThetaI);

    if (sinThetaSqr > 1.0f) {
        return 1.0f;// Total internal reflection
    }

    float cosThetaT = sqrt(1.0f - sinThetaSqr);

    float Rs = (eta * cosThetaI - cosThetaT)
    / (eta * cosThetaI + cosThetaT);
    float Rp = (cosThetaI - eta * cosThetaT)
    / (cosThetaI + eta * cosThetaT);

    return (Rs * Rs + Rp * Rp) / 2.0f;
}

// Rendering Vorlesung - Nori src/common.cpp
float fresnelConductor(in float cosThetaI, in float eta, in float k) {
    if (cosThetaI < 0.0f) {
        cosThetaI = -cosThetaI;
    }

    // via http://web.cse.ohio-state.edu/~parent.1/classes/782/Lectures/05_Reflectance_Handout.pdf, slide "Fresnel Reflection - Conductor"
    float Rs2 = ((eta * eta + k * k) * cosThetaI * cosThetaI - 2 * eta * cosThetaI + 1)
    / ((eta * eta + k * k) * cosThetaI * cosThetaI + 2 * eta * cosThetaI + 1);
    float Rp2 = ((eta * eta + k * k) - 2 * eta * cosThetaI + cosThetaI * cosThetaI)
    / ((eta * eta + k * k) + 2 * eta * cosThetaI + cosThetaI * cosThetaI);

    return (Rs2 + Rp2) / 2.0f;
}


// Beckmann Distribution https://www.graphics.cornell.edu/~bjw/microfacetbsdf.pdf
float D(in Material mat, in vec3 n, in vec3 m) {
    float cosTheta = dot(n, m);

    if (cosTheta <= 0) {
        return 0.0;
    }

    float theta = acos(cosTheta);

    if (isnan(theta) || isinf(theta)) {
        theta = 0;
    }


    float tanTheta = tan(theta);

    if (isnan(tanTheta) || isinf(tanTheta)) {
        tanTheta = 0;
    }

    float alphaSqr = (mat.roughness * mat.roughness);

    return pow(E, - tanTheta * tanTheta / alphaSqr) / (M_PI * alphaSqr * pow(cosTheta, 4));
}

float G1(in Material mat, in vec3 n, in vec3 m, in vec3 v) {
    float thetaV = dot(v, n);
    float c = dot(v, m) / thetaV;

    if (c <= 0) {
        return 0;
    }


    float a = 1.0 / (mat.roughness * tan(thetaV));

    if (a >= 1.6) {
        return 1.0;
    } else {
        float a2 = a * a;
        return (3.535 * a + 2.181 * a2)/(1 + 2.276 * a + 2.577 * a);
    }

}

float G(in Material mat, in vec3 i, in vec3 o, in vec3 n, in vec3 m) {
    float result = G1(mat, n, m, i) * G1(mat, n, m, o);
    if (result < 0) {
        return 0;
    }
    return result;
}

vec3 diffuse(in Material mat, in vec2 uv) {
    if (mat.textureIdDiffuse != -1) {
        return mat.diffuse * texture(textureSamplers[mat.textureIdDiffuse], uv).xyz /
        M_PI;
    } else {
        return mat.diffuse / M_PI;
    }
}

// Energy conserving phong method (Lewis ?)
vec3 phong(in Material mat, in vec2 uv, in vec3 normal, in vec3 wi, in vec3 wo) {
    vec3 res = vec3(0.0, 0.0, 0.0);

    float cosThetaWo = dot(wo, normal);
    if (cosThetaWo > 0) {
        if (mat.textureIdDiffuse != -1) {
            res += mat.diffuse * texture(textureSamplers[mat.textureIdDiffuse], info.textureUV).xyz /
            M_PI;
        } else {
            res += mat.diffuse / M_PI;
        }

        float dotReflDir = dot(reflect(-wo, normal), wi);
        if (dotReflDir > 0) {
            if (mat.textureIdSpecular != -1) {
                res += (mat.specularHighlight + 2) / (2 * M_PI) * mat.specular * pow(dotReflDir, mat.specularHighlight) *
                texture(textureSamplers[mat.textureIdSpecular], info.textureUV).xyz;
            } else {
                res += (mat.specularHighlight + 2) / (2 * M_PI) * mat.specular * pow(dotReflDir, mat.specularHighlight);
            }
        }

    }

    return cosThetaWo * res;
}

vec3 roughConductor(in Material mat, in vec3 normal, in vec3 wi, in vec3 wo) {
    vec3 hr = normalize(wi + wo);
    float cosThetaIHr = dot(wi, hr);
    float cosThetaI = dot(wi, normal);
    float cosThetaO = dot(wo, normal);

    if (cosThetaI <= 0) {
        return vec3(0);
    }

    return cosThetaO * (fresnelConductor(cosThetaIHr, mat.eta, mat.k) * G(mat, wi, wo, normal, hr) * D(mat, normal, hr) / (4 * cosThetaI * cosThetaO)).xxx;
}



float pdfBSDF(in Material mat, in vec3 normal, in vec3 wi, in vec3 wo) {
    switch (mat.type) {
        case MAT_ROUGH_CONDUCTOR:
        vec3 hr = normalize(wi + wo);
        float pm = D(mat, normal, hr) * abs(dot(hr, normal));

        if (pm <= 0 || dot(wo, hr) <= 0) {
            return 0.0;
        }

        return pm / (4 * abs(dot(wo, hr)));

        case MAT_PHONG:// Phong
        if (dot(normal, wo) < 0) {
            // Absorb rays below surface
            return 0.0;
        }

        float lDiffuse = length(mat.diffuse);
        float lSpecular = length(mat.specular);
        float sumSpecDiff = lDiffuse + lSpecular;

        // Completely black objects would produce NaN otherwise
        if (sumSpecDiff == 0) {
            return 0.0;
        }


        // Combine the probabilities of the two sampling methods
        // Cosine power/phong lobe
        vec3 reflected = reflect(-wi, normal);
        float highlight = mat.specularHighlight;

        float pdf = 0;
        if (dot(reflected, wo) > 0) {
            pdf = (highlight + 1) * pow(dot(reflected, wo), highlight) / (2 * M_PI);
            pdf *= lSpecular / sumSpecDiff;
        }

        // Cosine Hemisphere
        pdf += dot(wo, normal) / M_PI * lDiffuse / sumSpecDiff;

        return pdf;

        case MAT_DIFFUSE:// Cosine Hemisphere
        default :
        return dot(wo, normal) / M_PI;
    }
}

float pdfLight(in Light light, in vec3 lightDir, in vec3 lightNormal, in float lightDistance) {
    float cosThetaLight = dot(-lightDir, lightNormal);

    return light.sampleProb * lightDistance * lightDistance /
    cosThetaLight / light.area;
}

float powerHeuristic(in float pdf1, in float pdf2) {
    float sqr_p1 = pdf1 * pdf1;
    return sqr_p1 / (sqr_p1 + pdf2 * pdf2);
}

float balanceHeuristic(in float pdf1, in float pdf2) {
    return pdf1 / (pdf1 + pdf2);
}

/**
 * Select a random light and a position on it
 * @param vec3
 * @param vec3
 * @param vec3
 * @param lightDistance
 * @return
 */
float sampleLights(in vec3 origin, in vec3 normal, out vec3 lightDir, out vec3 lightColor, out float lightDistance) {
    // Next event estimation
    // Sample random light

    int iRandomLight;
    int iLight;
    Light light;

    iRandomLight = getRandomInteger(SIZE_LIGHT_RANDOM - 1);

    iLight = randomLigthIndex[iRandomLight];
    light = lights[iLight];

    if (light.type == LIGHT_POINT_LIGHT) {
        // Point light
        vec3 toLight = light.pos - origin;
        lightDistance = length(toLight);
        lightDir = toLight / lightDistance;

        lightColor = light.color / (lightDistance * lightDistance);
        return light.sampleProb;
    } else if (light.type == LIGHT_SPHERE) {
        // Sphere
        sphere s = spheres[light.instanceIndex];

        lightColor = mats[s.materialIndex].lightColor;

        vec3 sphereNormal;
        float area;
        vec3 position;
        if (pushC.useVisibleSphereSampling) {
            // Only sample the visible side of the sphere
            // => only half of the light area
            area = light.area / 2.0;
            position = randomOnSphereVisible(s, normal, sphereNormal);
        } else {
            area = light.area;
            position = randomOnSphere(s, sphereNormal);
        }
        vec3 toLight = position - origin;

        lightDistance = length(toLight);
        lightDir = normalize(toLight);

        float cosThetaLight = dot(-lightDir, sphereNormal);

        return light.sampleProb * lightDistance * lightDistance /
        (cosThetaLight * area);
    } else if (light.type == LIGHT_ENV_MAP) {
        // Env Map
        lightDir = randomInHemisphere(normal);


        float atan = atan(lightDir.x, -lightDir.z);
        float u = atan * M_INV_2PI;
        float v = acos(lightDir.y) / M_PI;

        vec2 envMapUV = vec2(u, v);
        lightColor = texture(textureSamplers[0], envMapUV).xyz;
        lightDistance = tMax;

        float cosThetaLight = dot(-lightDir, normal);
        // TODO: PDF envmap
        return light.sampleProb * M_INV_2PI;
    } else {
        // Area light
        int iModel = instanceInfos[light.instanceIndex].modelIndex;

        int iRandomTri = getRandomInteger(SIZE_TRI_RANDOM - 1);
        FaceSample triSample = randomTriIndex[iLight][iRandomTri];

        int iTri = triSample.index;

        ivec3 ind = ivec3(indices[iModel].i[3 * iTri + 0], //
        indices[iModel].i[3 * iTri + 1], //
        indices[iModel].i[3 * iTri + 2]);//

        // Vertex of the triangle
        Vertex v0 = vertices[iModel].v[ind.x];
        Vertex v1 = vertices[iModel].v[ind.y];
        Vertex v2 = vertices[iModel].v[ind.z];

        // Uniform random point on triangle
        vec2 randomXY = vec2(rnd(), rnd());
        float sqrtx = sqrt(randomXY.x);
        float sqrty = sqrt(randomXY.y);
        vec3 barycentrics = vec3(1.0 - sqrtx, sqrtx * (1.0 - randomXY.y), randomXY.y * sqrtx);

        // Computing the coordinates of the hit position
        vec3 lightSampleWorldPos = v0.pos * barycentrics.x + v1.pos * barycentrics.y + v2.pos * barycentrics.z;
        vec3 lightSampleNormal = v0.normal * barycentrics.x + v1.normal * barycentrics.y + v2.normal * barycentrics.z;

        // Transforming the position and normal to world space
        mat4 transform = instanceInfos[light.instanceIndex].transform;
        mat4 normalTransform = instanceInfos[light.instanceIndex].normalTransform;
        lightSampleWorldPos = (transform * vec4(lightSampleWorldPos, 1.0)).xyz;
        lightSampleNormal = (normalTransform * vec4(lightSampleNormal, 0.0)).xyz;

        // Normalize normal, because scaling
        lightSampleNormal = normalize(lightSampleNormal);

        vec3 toLight = lightSampleWorldPos - origin;
        lightDistance = length(toLight);
        lightDir = toLight / lightDistance;

        lightColor = mats[v0.materialIndex].lightColor;

        float cosThetaLight = dot(-lightDir, lightSampleNormal);
        if (cosThetaLight < 0) {
            cosThetaLight = -cosThetaLight;
        }

        return light.sampleProb * lightDistance * lightDistance /
        cosThetaLight / light.area;
    }
}

/**
 *
 * @param Material
 * @param vec3
 * @param vec3
 * @param vec3
 * @return pdf
 */
float sampleBSDF(in Material mat, in vec3 wi, in vec3 normal, in bool frontFace, out vec3 newDirection) {
    switch (mat.type) {
        case MAT_ROUGH_CONDUCTOR:
        vec3 worldM = randomBeckmannNormal(mat, normal);

        newDirection = reflect(-wi, worldM);

        return pdfBSDF(mat, normal, wi, newDirection);

        case MAT_PHONG:
        float lDiffuse = length(mat.diffuse);
        float lSpecular = length(mat.specular);
        float sumSpecDiff = lDiffuse + lSpecular;

        // Completely black objects would produce NaN otherwise
        if (sumSpecDiff == 0) {
            return 0.0;
        }

        float pdf;
        if (rnd() * sumSpecDiff > lDiffuse) {
            // Cosine power/phong lobe
            vec3 reflected = reflect(-wi, normal);

            float highlight = mat.specularHighlight;
            newDirection = randomInHemisphereCosinePower(reflected, highlight);

            if (dot(normal, newDirection) < 0) {
                // Absorb rays below surface
                return 0.0;
            }

            return pdfBSDF(mat, normal, wi, newDirection);
        } else {
            // Cosine Hemisphere
            newDirection = randomInHemisphereCosine(normal);
            return pdfBSDF(mat, normal, wi, newDirection);
        }


        case MAT_SPECULAR:
        case MAT_CONDUCTOR:
        newDirection = reflect(-wi, normal);
        return 1.0;

        case MAT_DIELECTRIC:
        float eta = mat.refractionIndexInv;

        if (!frontFace) {
            eta = mat.refractionIndex;
        }
        float cosThetaI = dot(wi, normal);
        float fresnel = fresnel(eta, cosThetaI);
        if (rnd() > fresnel) {
            // Refract
            newDirection = refract(-wi, normal, eta);
            return 1.0 - fresnel;
        } else {
            // Reflect
            newDirection = reflect(-wi, normal);
            return fresnel;
        }

        case MAT_DIFFUSE:
        default :
        // Cosine Hemisphere
        newDirection = randomInHemisphereCosine(normal);
        return dot(newDirection, normal) / M_PI;
    }
}

/**
 * For discrete direction material, assume that wo is one of the correct directions
 */
vec3 evalBsdf(Material mat, vec2 uv, vec3 normal, vec3 wi, vec3 wo, bool frontFace) {
    switch (mat.type) {
        case MAT_DIFFUSE:
        case MAT_LIGHT:
        return dot(wo, normal) * diffuse(mat, uv);
        case MAT_PHONG:
        return phong(mat, uv, normal, wi, wo);

        case MAT_ROUGH_CONDUCTOR:
        vec3 result = roughConductor(mat, normal, wi, wo);
        if (isnan(result.x)) {
            return vec3(0);
        }
        return result;
        case MAT_DIELECTRIC:
        {
            float cosThetaI = dot(normal, wi);

            float eta = mat.refractionIndexInv;
            if (!frontFace) {
                eta = mat.refractionIndex;
            }

            if (dot(normal, wo) < 0) {
                // Refraction
                return mat.specular * (1 - fresnel(eta, cosThetaI));
            } else {
                // Reflect
                return mat.specular * fresnel(eta, cosThetaI);
            }
        }
        case MAT_CONDUCTOR:
        {
            float cosTheta = dot(wi, normal);
            return fresnelConductor(cosTheta, mat.eta, mat.k).xxx;
        }
        case MAT_SPECULAR:
        return mat.specular;

        default :
        return vec3(0, 0, 0);
    }
}

vec3 nextEventEstimation(Material mat, vec3 origin, vec3 wi, vec3 normal) {
    switch (mat.type) {
        case MAT_DIFFUSE:
        case MAT_PHONG:
        case MAT_LIGHT:
        case MAT_ROUGH_CONDUCTOR:
        break;
        default :
        // Only run NEE for those materials that are supported
        return vec3(0, 0, 0);
    }

    vec3 neeResult = vec3(0, 0, 0);

    // Sample random light
    vec3 lightDir;
    vec3 lightColor;
    float lightDistance;
    float pdfLights = sampleLights(origin, normal, lightDir, lightColor, lightDistance);

    vec2 textureUV = info.textureUV;

    // Check if shadowed
    shadowInfo.isShadowed = true;

    float cosThetaLight = dot(normal, lightDir);
    if (cosThetaLight > 0 && pdfLights > 0) {
        traceRayEXT(topLevelAS, // acceleration structure
        shadowRayFlags, // rayFlags
        0xFF, // cullMask
        0, // sbtRecordOffset
        0, // sbtRecordStride
        1, // missIndex of shadow miss
        origin.xyz, // ray origin
        tMin, // ray min range
        lightDir, // ray direction
        lightDistance * (1 - 0.0001), // ray max range
        PAYLOAD_SHADOW// payload
        );
    }

    if (!shadowInfo.isShadowed) {

        if (pushC.enableMIS) {
            // MIS
            float pdfMat = pdfBSDF(mat, normal, wi, lightDir);

            float heuristic;
            if (pushC.usePowerHeuristic) {
                heuristic = powerHeuristic(pdfLights, pdfMat);
            } else {
                heuristic = balanceHeuristic(pdfLights, pdfMat);
            }

            if (isnan(heuristic)) {
                return neeResult;
            }

            neeResult += evalBsdf(mat, textureUV, normal, wi, lightDir, true) *
            lightColor * heuristic / pdfLights;
        } else {
            neeResult = evalBsdf(mat, textureUV, normal, wi, lightDir, true)
            * lightColor / pdfLights;
        }
    }

    if (pushC.enableMIS) {
        // Direct light check with BSDF sample
        vec3 bsdfDir;
        float pdfMat = sampleBSDF(mat, wi, normal, info.isFrontFace, bsdfDir);

        if (pdfMat > 0)  {
            traceRayEXT(topLevelAS, // acceleration structure
            rayFlags, // rayFlags
            0xFF, // cullMask
            0, // sbtRecordOffset
            0, // sbtRecordStride
            0, // missIndex
            origin.xyz, // ray origin
            tMin, // ray min range
            bsdfDir, // ray direction
            tMax, // ray max range
            PAYLOAD_HIT// payload
            );

            if (info.isMiss) {
                lightColor = info.missColor;
                pdfLights = M_INV_2PI / lightCount;

                float heuristic;
                if (pushC.usePowerHeuristic) {
                    heuristic = powerHeuristic(pdfMat, pdfLights);
                } else {
                    heuristic = balanceHeuristic(pdfMat, pdfLights);
                }

                neeResult += evalBsdf(mat, textureUV, normal, wi, bsdfDir, true) *
                lightColor * heuristic / pdfMat;
            } else {
                // Check if a light was hit at all
                Material matSample = mats[info.matIndex];
                if (matSample.type == MAT_LIGHT) {
                    int iLight;
                    if (info.isSphere) {
                        iLight = spheres[info.instanceIndex].iLight;
                    } else {
                        iLight = instanceInfos[info.instanceIndex].iLight;
                    }
                    Light light = lights[iLight];

                    lightColor = matSample.lightColor;
                    pdfLights = pdfLight(light, bsdfDir, info.normal, info.t);

                    float heuristic;
                    if (pushC.usePowerHeuristic) {
                        heuristic = powerHeuristic(pdfMat, pdfLights);
                    } else {
                        heuristic = balanceHeuristic(pdfMat, pdfLights);
                    }

                    if (isnan(heuristic)) {
                        return neeResult;
                    }

                    neeResult += evalBsdf(mat, textureUV, normal, wi, bsdfDir, true) *
                    lightColor * heuristic / pdfMat;
                }
            }

        }
    }
    return neeResult;
}

bool hasDiscreteDirection(Material mat) {
    switch (mat.type) {
        case MAT_DIELECTRIC:
        case MAT_SPECULAR:
        case MAT_CONDUCTOR:
        return true;
        default :
        return false;
    }
}


/**
* returns true if cache hits found
*/
bool queryIrradianceCache(vec3 origin, vec3 normal, out vec3 color) {
    cacheInfo.origin = origin;
    cacheInfo.normal = normal;
    cacheInfo.cacheValueSum = vec3(0, 0, 0);
    cacheInfo.totalWeight = 0;

    traceRayEXT(irradianceAS, // acceleration structure
    gl_RayFlagsSkipClosestHitShaderEXT, // rayFlags
    0xFF, // cullMask
    0, // sbtRecordOffset
    0, // sbtRecordStride
    0, // missIndex
    origin.xyz, // ray origin
    0, // ray min range
    normal.xyz, // ray direction
    tMin, // ray max range
    PAYLOAD_IC// payload
    );

    if (cacheInfo.totalWeight > 0) {
        color = cacheInfo.cacheValueSum / cacheInfo.totalWeight;
        return true;
    }

    return false;
}


/**
* returns true if cache hits found
*/
bool queryIrradianceCacheGradients(vec3 origin, vec3 normal, out vec3 color) {
    cacheInfo.origin = origin;
    cacheInfo.normal = normal;
    cacheInfo.cacheValueSum = vec3(0, 0, 0);
    cacheInfo.totalWeight = 0;

    traceRayEXT(irradianceAS, // acceleration structure
    gl_RayFlagsSkipClosestHitShaderEXT, // rayFlags
    0xFF, // cullMask
    VISU_HITGROUP_OFFSET, // sbtRecordOffset
    0, // sbtRecordStride
    0, // missIndex
    origin.xyz, // ray origin
    0, // ray min range
    normal.xyz, // ray direction
    tMin, // ray max range
    PAYLOAD_IC// payload
    );

    if (cacheInfo.totalWeight > 0) {
        color = cacheInfo.cacheValueSum / cacheInfo.totalWeight;
        return true;
    }

    return false;
}

bool isICCapable(Material mat) {
    if (mat.type == MAT_DIFFUSE || mat.type == MAT_LIGHT) {
        return true;
    } else if (pushC.useIrradianceCacheOnGlossy && !hasDiscreteDirection(mat)) {
        return true;
    }
    return false;
}

vec3 approxDiffuse(Material mat, vec3 normal, vec3 wi, vec2 uv) {
    switch (mat.type) {
        case MAT_DIFFUSE:
        case MAT_LIGHT:
        case MAT_PHONG:
        return diffuse(mat, uv);

        case MAT_ROUGH_CONDUCTOR:
        // Normal conductor but with 1/pi weighting
        float cosTheta = dot(wi, normal);
        return fresnelConductor(cosTheta, mat.eta, mat.k).xxx * M_INV_PI;
    }
    return vec3(-1, -1, -1);
}

float applyWeightWindow(vec3 throughput, vec3 adjoint, out int n) {
    // Calculate WW
    float center = length(estimate / adjoint);
    float lower = 2 * center / (1 + pushC.adrrsS);
    float upper = pushC.adrrsS * lower;

    float v = length(throughput);

    // Esitmate or adjoint 0
    // => No prediction possible
    if (isnan(lower) || lower <= 0) {
        n = 1;
        return 1.0;
    }

    if (lower <= v && v <= upper) {
        // No change
        n = 1;
        return 1.0;
    } else if (v <= lower) {
        // RR
        n = 1;

        // No very small q allowed
        // => could result in high variance
        return max(v / lower, 0.1);
    } else {
        // Splitting
        float q = v / upper;

        n = int(q);

        // Non integer solution
        // => expected-value split
        if (rnd() > (n + 1 - q)) {
            n++;
        }
        return q;
    }
}

vec3 multipleNEE(Material mat, vec3 origin, vec3 wi, vec3 normal, int numNEE) {
    vec3 result = vec3(0, 0, 0);
    for (int i = 0; i < numNEE; i++) {
        result += nextEventEstimation(mat, origin, wi, normal);
    }
    return result / numNEE;
}

/**
* Stores the parameters to start a new split ray from that position.
* @returns false if max splits reached
*/
bool split(vec3 origin, vec3 normal, vec3 wi, vec3 throughput, vec2 textureUV, int matIndex, int currentDepth, bool isFrontFace) {
    if (nextSplitSlot >= MAX_SPLITS) {
        return false;
    }

    splitInfo split;
    split.origin = origin;
    split.normal = normal;
    split.wi = wi;
    split.throughput = throughput;
    split.textureUV = textureUV;
    split.matIndex = matIndex;
    split.currentDepth = currentDepth;
    split.isFrontFace = isFrontFace;

    splits[nextSplitSlot] = split;
    nextSplitSlot++;

    return true;
}

uint getGuidingRegion(vec3 origin) {
    guidingInfos.iRegion = -1;

    traceRayEXT(guidingAS, // acceleration structure
    gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT, // The current position should always only be in one guiding region
    0xFF, // cullMask
    0, // sbtRecordOffset
    0, // sbtRecordStride
    0, // missIndex
    origin, // ray origin
    0, // ray min range
    vec3(0, 0, 1), // ray direction
    tMin, // ray max range
    PAYLOAD_GUIDING// payload
    );

    return guidingInfos.iRegion;
}

float getNewDirection(Material mat, vec3 origin, vec3 normal, vec3 wi, out vec3 newDirection) {
    float pdf;

    if (pushC.useGuiding && !hasDiscreteDirection(mat)) {
        // Guiding is only possible for non-discrete direction materials

        uint iRegion = getGuidingRegion(origin);

        if (iRegion == -1) {
            return 0.0;
        }

        VMM_Theta vmmTheta = guidingVMM[iRegion];

        float pdfMat;
        if (rnd() < pushC.guidingProb) {
            newDirection = sampleVMM(vmmTheta, origin, pushC.useParallaxCompensation);
            pdfMat = pdfBSDF(mat, normal, wi, newDirection);
        } else {
            pdfMat = sampleBSDF(mat, wi, normal, info.isFrontFace, newDirection);
        }

        if (dot(newDirection, normal) < 0 || pdfMat <= 0) {
            return 0.0;
        }

        float pdfGuiding = VMM(newDirection, vmmTheta, origin, pushC.useParallaxCompensation);

        if (isnan(pdfGuiding)) {
            return sampleBSDF(mat, wi, normal, info.isFrontFace, newDirection);
        }

        pdf = mix(pdfMat, pdfGuiding, pushC.guidingProb);
    } else {
        pdf = sampleBSDF(mat, wi, normal, info.isFrontFace, newDirection);
    }
    return pdf;
}

bool isMatAlmostDiscrete(Material mat) {
    return (mat.type == MAT_ROUGH_CONDUCTOR && mat.roughness <= 0.3) || (mat.type == MAT_PHONG && mat.specularHighlight >= 250.0);
}

uint getBaseIndex() {
    return (gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x) * MAX_DIRECTIONAL_DATA_PER_PIXEL;
}

/**
* Update all previous samples by multiplying the throughput of all samples after them to the light value
*/
void updateSamples(int currentSampleOffset, vec3 light) {
    for (int iSample = currentSampleOffset - 1; iSample >= sampleOffset; iSample--) {
        lightSums[iSample] += light;
        light *= sampleThroughputs[iSample];
    }
}

void commitSamples(int currentSampleOffset) {
    for (int iSample = sampleOffset; iSample < currentSampleOffset; iSample++) {
        float weight = length(lightSums[iSample]) / directionalData[getBaseIndex() + iSample].pdf;
        if (weight <= 0) {
            directionalData[getBaseIndex() + iSample].flags = INVALID;
        } else {
            directionalData[getBaseIndex() + iSample].weight = weight;// Does cosTheta need to be applied?
        }

    }
}

vec3 raytrace(vec3 origin, vec3 direction, vec3 throughput, inout int currentDepth, int maxDepth, int maxFollowDiscrete, bool addDirectLights, bool addFirstHitLight, bool useNEE, int numNEE, bool useIC, bool createIC, bool useADRRS, bool saveSamples, out float firstT) {
    bool follow = true;
    int followCount = 0;
    bool addNextDirectLights = addFirstHitLight;
    float r = tMax;
    int depth = currentDepth;
    vec3 normal;
    firstT = tMax;


    int currentSampleOffset = sampleOffset;
    int iUpdateDistance = -1;
    float distanceFactor = 1.0;

    vec3 result = vec3(0.0, 0.0, 0.0);

    do {
        depth++;

        traceRayEXT(topLevelAS, // acceleration structure
        rayFlags, // rayFlags
        0xFF, // cullMask
        0, // sbtRecordOffset
        0, // sbtRecordStride
        0, // missIndex
        origin.xyz, // ray origin
        tMin, // ray min range
        direction.xyz, // ray direction
        tMax, // ray max range
        PAYLOAD_HIT// payload
        );


        if (info.isMiss) {
            if (addDirectLights || addNextDirectLights) {
                result += throughput * info.missColor;

                if (saveSamples) {
                    updateSamples(currentSampleOffset, info.missColor);

                    // Update distance data
                    if (iUpdateDistance != -1) {
                        // Distance infinity
                        directionalData[getBaseIndex() + iUpdateDistance].distance = 0;
                    }
                }
            }
            break;
        }

        // Get hit properties
        Material mat = mats[info.matIndex];
        origin = info.worldPos;
        normal = info.normal;

        // For average distance calculation
        if (depth == 1) {
            firstT = info.t;
        }

        // Light hit
        if (mat.type == MAT_LIGHT && (addDirectLights || addNextDirectLights)) {
            result += throughput * mat.lightColor;

            if (saveSamples) {
                updateSamples(currentSampleOffset, mat.lightColor);
            }
        }

        if (hasDiscreteDirection(mat)) {
            // The next direct light hit has to contribute, as mirrors would be black otherwise
            addNextDirectLights = true;

            // When there is a discrete direction, NEE is not possible and we should continue on, even if depth > maxDepth
            follow = true;
            if (depth >= maxDepth) {
                followCount++;
            }

            // Update distance data
            if (saveSamples && iUpdateDistance != -1) {
                directionalData[getBaseIndex() + iUpdateDistance].distance += info.t * distanceFactor;
            }
        } else {
            addNextDirectLights = false;
            follow = false;

            if (useIC || (useADRRS && (depth > 1))) {
                // If diffuse (or non-discrete if enabled), then check if irradiance cache is nearby
                if (isICCapable(mat)) {
                    vec3 irradianceColor;
                    if (queryIrradianceCache(origin, normal, irradianceColor)) {
                        vec3 diffuse = approxDiffuse(mat, normal, -direction, info.textureUV);

                        if (useADRRS) {
                            vec3 adjoint = diffuse * irradianceColor;

                            int n;
                            float q = applyWeightWindow(throughput, irradianceColor, n);


                            if (n == 1) {
                                // RR
                                if (rnd() > q) {
                                    // Ray dies
                                    break;
                                }

                                throughput /= q;
                            } else if (pushC.adrrsSplit){
                                // Check if that many splits are even allowed
                                int possibleSplits = MAX_SPLITS - nextSplitSlot;
                                if (n - 1 > possibleSplits) {
                                    n = possibleSplits + 1;
                                    q = n;
                                }

                                throughput /= q;

                                // n => n - 1 splits, because the current ray continues on
                                for (int iSplit = 0; iSplit < n - 1; iSplit++) {
                                    split(origin, normal, -direction, throughput, info.textureUV, info.matIndex, depth, info.isFrontFace);
                                }
                            }
                        } else {
                            // Record found -> use it
                            result += throughput * diffuse * irradianceColor;

                            // If IC values are used, then NEE is necessary for the complete light values
                            result += throughput * multipleNEE(mat, origin, -direction, normal, numNEE);
                            break;
                        }
                    } else if (createIC && rnd() < pushC.irradianceCreateProb) {
                        // No record found -> create one
                        // All irradiance cache values are only available in the next frame,
                        // Therefore we need to limit the amount of cache entries created, as otherwise all rays would create one

                        if (nextNewIrradianceCacheSlot < MAX_NEW_IRRADIANCE_ENTRIES) {
                            newIrradianceCacheInfo newCacheInfo;
                            newCacheInfo.origin = origin;
                            newCacheInfo.normal = normal;

                            newIrradianceCacheEntries[nextNewIrradianceCacheSlot] = newCacheInfo;
                            nextNewIrradianceCacheSlot++;
                        }
                    }
                }
            }

            if (pushC.splitOnFirst && depth == 1) {
                if (split(origin, normal, -direction, throughput * 0.5, info.textureUV, info.matIndex, depth, info.isFrontFace)) {
                    throughput *= 0.5;
                }
            }

            // Update distance for last directionalData
            if (saveSamples && iUpdateDistance != -1) {
                directionalData[getBaseIndex() + iUpdateDistance].distance += info.t * distanceFactor;

                if (!isMatAlmostDiscrete(mat)) {
                    // Mark the last distance entry as final
                    iUpdateDistance = -1;
                }
            }

            // NEE is after possible splits, as each split should calculate its own NEE
            if (useNEE) {
                vec3 neeLight = multipleNEE(mat, origin, -direction, normal, numNEE);
                result += throughput * neeLight;

                if (saveSamples) {
                    updateSamples(currentSampleOffset, neeLight);
                }
            }
        }

        vec3 newDirection;
        float pdf = getNewDirection(mat, origin, normal, -direction, newDirection);

        if (pdf <= 0.0) {
            break;
        }

        vec3 throughputChange = evalBsdf(mat, info.textureUV, normal, -direction, newDirection, info.isFrontFace) / pdf;
        throughput *= throughputChange;

        if (saveSamples && currentSampleOffset < MAX_DIRECTIONAL_DATA_PER_PIXEL) {
            if (hasDiscreteDirection(mat) || isMatAlmostDiscrete(mat)) {
                // Discrete direction (or close to it) => because of probabilities instead of pdf we can not use this data
                directionalData[getBaseIndex() + currentSampleOffset].flags = INVALID;
            } else {
                // Create new directional data on all non-discrete direction surfaces
                DirectionalData sampleData;
                sampleData.position = origin;
                sampleData.direction = newDirection;
                sampleData.pdf = pdf;
                sampleData.weight = 0;
                sampleData.distance = 0;
                sampleData.flags = getGuidingRegion(origin);
                directionalData[getBaseIndex() + currentSampleOffset] = sampleData;

                iUpdateDistance = currentSampleOffset;
                distanceFactor = 1.0;
            }

            lightSums[currentSampleOffset] = vec3(0);
            sampleThroughputs[currentSampleOffset] = throughputChange;
            currentSampleOffset++;
        } else if (iUpdateDistance != -1 && mat.type == MAT_DIELECTRIC && dot(newDirection, normal) < 0) {
            // Refraction
            float eta = mat.refractionIndex;

            if (!info.isFrontFace) {
                // Leaving dielectric
                eta = mat.refractionIndexInv;
            }

            // Next distance value has to take into account the apparent distance
            distanceFactor = abs(dot(normal, direction) / dot(normal, newDirection)) * eta;
        }

        direction = newDirection;
    } while (depth <= maxDepth || (follow && followCount <= maxFollowDiscrete));

    commitSamples(currentSampleOffset);
    sampleOffset += currentSampleOffset;

    currentDepth = depth;
    return result;
}

/**
* returns the harmonicR
*/
float calculateCacheData(in vec3 origin, in vec3 normal, out vec3 calculatedColor, out vec3 rotGrad, out vec3 transGrad) {
    const int N = 20;
    const int M = 10;

    float invDistanceSum = 0;
    int numDistances = 0;
    int maxFollowDiscrete = 10;
    bool createIC = false;
    const bool addDirectLights = false;


    vec3 hitNormal, hitOrigin;

    rotGrad = vec3(0, 0, 0);
    transGrad = vec3(0, 0, 0);
    vec3 color = vec3(0, 0, 0);
    for (int k = 0; k < N; k++) {
        float phi = 2 * M_PI * (k + rnd()) / N;

        vec3 uk = toWorld(sphericalToCartesian(M_HALF_PI, phi), normal);
        vec3 vk = toWorld(sphericalToCartesian(M_HALF_PI, phi + M_HALF_PI), normal);
        vec3 previousVk = toWorld(sphericalToCartesian(M_HALF_PI, 2 * M_PI * k / N + M_HALF_PI), normal);
        float previousKLs[N];
        float previousKRs[N];
        float previousJR;
        float previousJL;
        for (int j = 0; j < M; j++) {
            float theta = asin(sqrt((j + rnd()) / M));

            vec3 direction = toWorld(sphericalToCartesian(theta, phi), normal);

            float r = tMax;

            int currentDepth = 0;
            vec3 sampleColor = raytrace(origin, direction, vec3(1.0), currentDepth, 1, maxFollowDiscrete, addDirectLights, false, true, pushC.irradianceNumNEE, true, createIC, false, false, r);
            color += sampleColor;

            if (r < tMax) {
                invDistanceSum += 1.0 / r;
                numDistances++;
            }

            float L = length(sampleColor);
            float previousJTheta = asin(sqrt(j / float(M)));
            float nextJTheta = asin(sqrt((j + 1) / float(M)));

            // Rotation gradient
            float tanTheta = tan(theta);
            if (isinf(tanTheta) || isnan(tanTheta)) {
                tanTheta = 0;
            }
            rotGrad -= tanTheta * L * vk;

            // Translational gradient
            if (j > 0) {
                float cosPreviousTheta = cos(previousJTheta);
                transGrad  += uk * 2 * M_PI / N * sin(previousJTheta) * cosPreviousTheta * cosPreviousTheta / min(r, previousJR) * (L - previousJL);
            }

            if (k > 0) {
                transGrad += previousVk  * (sin(nextJTheta) - sin(previousJTheta)) / min(r, previousKRs[j]) * (L - previousKLs[j]);
            }

            previousKLs[j] = L;
            previousKRs[j] = r;
            previousJL = L;
            previousJR = r;
        }
    }

    float normFactor = M_PI / (M * N);
    calculatedColor = normFactor * color;
    rotGrad *= normFactor;



    float harmonicR;
    if (invDistanceSum == 0 || numDistances == 0) {
        // No hit => no light
        return -1;
    } else {
        harmonicR = 1.0 / (invDistanceSum / numDistances);
    }

    return harmonicR;
}

void clampGradients(inout vec3 rotGrad, inout vec3 transGrad) {
    // Gradients get scaled down if they surpass a maximum length
    float lengthRot = length(rotGrad);
    if (lengthRot > pushC.irradianceGradientsMaxLength) {
        rotGrad *= pushC.irradianceGradientsMaxLength / lengthRot;
    }

    float lengthTrans = length(transGrad);
    if (lengthTrans > pushC.irradianceGradientsMaxLength) {
        transGrad *= pushC.irradianceGradientsMaxLength / lengthTrans;
    }
}

/**
* Updates color and radius of cache entry
*/
void updateIrradianceCache() {
    uint cacheIndex = atomicAdd(header.nextUpdateSlot, 1);
    if (cacheIndex >= header.nextCacheSlot) {
        header.nextUpdateSlot = 0;
        return;
    }

    // unititialized
    if (cache[cacheIndex].numUpdates < 1) {
        return;
    }

    vec3 rotGrad;
    vec3 transGrad;
    vec3 calculatedColor;
    float harmonicR = calculateCacheData(cacheSpheres[cacheIndex].center, cache[cacheIndex].normal, calculatedColor, rotGrad, transGrad);

    uint numUpdates = cache[cacheIndex].numUpdates;

    float a = min(numUpdates / float(numUpdates + 1), 0.95);

    cache[cacheIndex].color = mix(calculatedColor, cache[cacheIndex].color, a);

    rotGrad = mix(rotGrad, cache[cacheIndex].rotGrad, a);
    transGrad = mix(transGrad, cache[cacheIndex].transGrad, a);
    clampGradients(rotGrad, transGrad);
    cache[cacheIndex].rotGrad = rotGrad;
    cache[cacheIndex].transGrad = transGrad;

    float radius;
    if (harmonicR > 0) {
        // harmonicR only gets updated if at least one object hit in hemisphere
        harmonicR = mix(harmonicR, cache[cacheIndex].harmonicR, a);
    } else {
        harmonicR = cache[cacheIndex].harmonicR;
    }

    // Lower bound for radius to prevent unlimited number of IC entries in corners
    harmonicR = max(harmonicR, pushC.irradianceCacheMinRadius);
    cache[cacheIndex].harmonicR = harmonicR;

    radius = pushC.irradianceA * harmonicR;

    cacheSpheres[cacheIndex].radius = radius;
    cacheAabbs[cacheIndex].min = cacheSpheres[cacheIndex].center - radius.xxx;
    cacheAabbs[cacheIndex].max = cacheSpheres[cacheIndex].center + radius.xxx;
    cache[cacheIndex].numUpdates += 1;
}

bool createIrradianceCache(vec3 origin, vec3 normal, out vec3 calculatedColor) {
    if (header.nextCacheSlot > header.maxCaches) {
        return false;
    }
    vec3 rotGrad;
    vec3 transGrad;
    float harmonicR = calculateCacheData(origin, normal, calculatedColor, rotGrad, transGrad);

    if (harmonicR < 0) {
        return false;
    }

    uint cacheIndex = atomicAdd(header.nextCacheSlot, 1);

    if (cacheIndex > header.maxCaches) {
        return false;
    }

    // Lower bound for radius to prevent unlimited number of IC entries in corners
    harmonicR = max(harmonicR, pushC.irradianceCacheMinRadius);

    clampGradients(rotGrad, transGrad);

    cache[cacheIndex].normal = normal;
    cache[cacheIndex].color = calculatedColor;
    cache[cacheIndex].harmonicR = harmonicR;
    cache[cacheIndex].rotGrad = rotGrad;
    cache[cacheIndex].transGrad = transGrad;
    cache[cacheIndex].numUpdates = 1;

    cacheSpheres[cacheIndex].center = origin;

    float radius = pushC.irradianceA * harmonicR;
    cacheSpheres[cacheIndex].radius = pushC.irradianceA * harmonicR;
    cacheAabbs[cacheIndex].min = origin - radius.xxx;
    cacheAabbs[cacheIndex].max = origin + radius.xxx;

    return true;
}

vec3 visualizeIC(vec3 origin, vec3 direction) {
    traceRayEXT(topLevelAS, // acceleration structure
    rayFlags, // rayFlags
    0xFF, // cullMask
    0, // sbtRecordOffset
    0, // sbtRecordStride
    0, // missIndex
    origin.xyz, // ray origin
    tMin, // ray min range
    direction.xyz, // ray direction
    tMax, // ray max range
    PAYLOAD_HIT// payload
    );

    if (info.isMiss) {
        return info.missColor;
    }

    vec3 icColor;
    if (pushC.showIrradianceGradients) {
        // extra gradient visualization shader
        if (queryIrradianceCacheGradients(info.worldPos, info.normal, icColor)) {
            return pushC.irradianceVisualizationScale * icColor;
        }
    } else {
        if (queryIrradianceCache(info.worldPos, info.normal, icColor)) {
            if (pushC.highlightIrradianceCacheColor) {
                icColor -= min(min(icColor.r, icColor.g), icColor.b).xxx;
            }

            return pushC.irradianceVisualizationScale * icColor;
        }
    }
    return vec3(0, 0, 0);
}

void saveResult(vec3 result) {
    ivec2 imageUV = ivec2(gl_LaunchIDEXT.xy);

    if (pushC.enableAverageInsteadOfMix) {
        // if the camera hasn't changed, then accumulate results
        if (pushC.previousFrames > 0) {
            vec3 accumulated = imageLoad(accumulateImage, imageUV).xyz;
            accumulated += result;

            imageStore(image, imageUV, vec4(accumulated / (pushC.previousFrames + 1), 1.0));
            imageStore(accumulateImage, imageUV, vec4(accumulated, 1.0));
        } else {
            imageStore(accumulateImage, imageUV, vec4(result, 1.0));
            imageStore(image, imageUV, vec4(result, 1.0));
        }
    } else {
        // if the camera hasn't changed, then mix with previous results
        if (pushC.previousFrames > 0) {
            vec3 previous = imageLoad(image, imageUV).xyz;
            result = mix(previous, result, 1.0 / (pushC.previousFrames + 1));

            imageStore(image, imageUV, vec4(result, 1.0));
        } else {
            imageStore(image, imageUV, vec4(result, 1.0));
        }
    }
}

void getCameraRay(const vec2 pixelCenter, out vec3 origin, out vec3 direction) {
    vec2 inUV = (pixelCenter + vec2(getRandomNegPos(), getRandomNegPos()) / 2.0) / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    origin = (cam.viewInverse * vec4(0, 0, 0, 1)).xyz;
    vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1);
    direction = normalize((cam.viewInverse * vec4(normalize(target.xyz), 0)).xyz);
}

vec3 colormapGuiding(float value) {
    if (value < 0.5) {
        return mix(vec3(0, 0, 1), vec3(0, 1, 0), 2 * value);
    } else {
        return mix(vec3(0, 1, 0), vec3(1, 0, 0), 2 * (value - 0.5));
    }
}

bool getGuidingDistributionVisualization(const vec2 pixelCenter, float maxT, int regionFilter, out vec3 color) {
    vec3 origin, direction;
    getCameraRay(pixelCenter, origin, direction);

    guidingVisuInfos.isMiss = true;
    guidingVisuInfos.iRegion = regionFilter;

    traceRayEXT(guidingAS, // acceleration structure
    rayFlags, // rayFlags
    0xFF, // cullMask
    VISU_HITGROUP_OFFSET, // sbtRecordOffset
    0, // sbtRecordStride
    0, // missIndex
    origin.xyz, // ray origin
    tMin, // ray min range
    direction.xyz, // ray direction
    maxT, // ray max range
    PAYLOAD_GUIDING_VISU// payload
    );

    if (guidingVisuInfos.isMiss) {
        return false;
    }

    VMM_Theta vmmTheta = guidingVMM[guidingVisuInfos.iRegion];
    float value = VMM(guidingVisuInfos.direction, vmmTheta, guidingVisuInfos.center, pushC.useParallaxCompensation);
    // Normalize to range [0,1]
    value = min(1.0, value / pushC.guidingVisuMax);

    // Generate color
    color = colormapGuiding(value);

    return true;
}

vec3 getGuidingRegionVisualization(const vec2 pixelCenter) {
    vec3 origin, direction;
    getCameraRay(pixelCenter, origin, direction);

    traceRayEXT(topLevelAS, // acceleration structure
    rayFlags, // rayFlags
    0xFF, // cullMask
    0, // sbtRecordOffset
    0, // sbtRecordStride
    0, // missIndex
    origin.xyz, // ray origin
    tMin, // ray min range
    direction.xyz, // ray direction
    tMax, // ray max range
    PAYLOAD_HIT// payload
    );

    if (info.isMiss) {
        return vec3(0, 0, 0);
    }

    uint iRegion = getGuidingRegion(info.worldPos.xyz);

    if (iRegion == -1) {
        return vec3(1, 0, 0);
    } else {
        // Visualize with random, but static color
        uint seed = iRegion;
        return vec3(rnd(seed), rnd(seed), rnd(seed));
    }
}

vec3 getGuidingActiveComponentsVisualization(const vec2 pixelCenter) {
    vec3 origin, direction;
    getCameraRay(pixelCenter, origin, direction);

    traceRayEXT(topLevelAS, // acceleration structure
    rayFlags, // rayFlags
    0xFF, // cullMask
    0, // sbtRecordOffset
    0, // sbtRecordStride
    0, // missIndex
    origin.xyz, // ray origin
    tMin, // ray min range
    direction.xyz, // ray direction
    tMax, // ray max range
    PAYLOAD_HIT// payload
    );

    if (info.isMiss) {
        return vec3(0, 0, 0);
    }

    uint iRegion = getGuidingRegion(info.worldPos.xyz);

    if (iRegion == -1) {
        return vec3(1, 0, 0);
    } else {
        float a = guidingVMM[iRegion].usedDistributions /  float(MAX_DISTRIBUTIONS);
        return mix(vec3(0, 0, 1), vec3(1, 0, 0), a);
    }
}

void saveEstimate(vec3 result) {
    ivec2 imageUV = ivec2(gl_LaunchIDEXT.xy);
    imageStore(estimateImage, imageUV, vec4(result, 1.0));
}

bool visualizeModeNeedsRaytracing() {
    if (pushC.visualizeMode < VISU_ESTIMATE || pushC.visualizeMode == VISU_GUIDING_OVERLAY || pushC.visualizeMode == VISU_GUIDING_PIP) {
        return true;
    } else {
        return false;
    }
}

void resetSamplesToInvalid() {
    uint baseIndex = getBaseIndex();

    for (int i = 0; i < MAX_DIRECTIONAL_DATA_PER_PIXEL; i++) {
        directionalData[baseIndex + i].flags = INVALID;
    }
}

void main() {
    // Init seed
    seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pushC.randomUInt);

    vec3 result = vec3(0.0, 0.0, 0.0);

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);

    // Store current pixel estimate for easy access
    if (pushC.useADRRS || pushC.visualizeMode == VISU_ESTIMATE) {
        ivec2 imageUV = ivec2(gl_LaunchIDEXT.xy);
        estimate = imageLoad(estimateImage, imageUV).xyz;
        lengthEstimate = length(estimate);
    }

    if (pushC.useIrradianceCache && rnd() < pushC.irradianceUpdateProb) {
        updateIrradianceCache();
    }

    if (pushC.updateGuiding) {
        resetSamplesToInvalid();

        // Samples can currently not be collected while splitting
        if ((pushC.useADRRS && pushC.adrrsSplit) || pushC.splitOnFirst) {
            return;
        }
    }

    const int numNEE = pushC.numNEE;
    const int maxDepth = pushC.maxDepth;
    int maxReachedDepth = 0;
    int depthSum = 0;
    int depthsCounter = 0;
    float firstT;

    if (visualizeModeNeedsRaytracing() || pushC.storeEstimate) {

        // Prepare frames should only have one sample per pixel
        const int samplesPerPixel = pushC.isIrradiancePrepareFrame ? 1 : pushC.samplesPerPixel;
        const int maxFollowDiscrete = pushC.maxFollowDiscrete;
        const bool useNEE = pushC.enableNEE;
        const bool addDirectLights = !useNEE;

        const bool useIC = pushC.useIrradianceCache;

        for (int iSample = 0; iSample < samplesPerPixel; ++iSample) {
            vec3 origin, direction;
            getCameraRay(pixelCenter, origin, direction);

            if (pushC.showIrradianceCacheOnly) {
                result += visualizeIC(origin, direction);
            } else {
                int currentDepth = 0;
                result += raytrace(origin, direction, vec3(1.0), currentDepth, maxDepth, maxFollowDiscrete, addDirectLights, true, useNEE, numNEE, useIC, true, pushC.useADRRS, pushC.updateGuiding, firstT);
                maxReachedDepth = max(maxReachedDepth, currentDepth);
                depthSum += currentDepth;
                depthsCounter++;
            }
        }


        for (int iSplit = 0; iSplit < nextSplitSlot; iSplit++) {
            splitInfo split = splits[iSplit];

            Material mat = mats[split.matIndex];

            // Split happens before NEE
            // => calculate NEE for origin
            if (useNEE) {
                result += split.throughput * multipleNEE(mat, split.origin, split.wi, split.normal, numNEE);
            }

            vec3 direction;
            float pdf = getNewDirection(mat, split.origin, split.normal, split.wi, direction);

            if (pdf <= 0.0) {
                break;
            }
            vec3 throughput = split.throughput * evalBsdf(mat, split.textureUV, split.normal, split.wi, direction, split.isFrontFace) / pdf;

            result += raytrace(split.origin, direction, throughput, split.currentDepth, maxDepth, maxFollowDiscrete, addDirectLights, false, useNEE, numNEE, useIC, true, pushC.useADRRS, pushC.updateGuiding, firstT);

            maxReachedDepth = max(maxReachedDepth, split.currentDepth);
            depthSum += split.currentDepth;
            depthsCounter++;
        }

        result /= samplesPerPixel;
    }

    if (pushC.storeEstimate) {
        saveEstimate(result);
    }

    switch (pushC.visualizeMode) {
        case VISU_RAYTRACE:
        saveResult(result);
        break;
        case VISU_DEPTH_MAX:
        {
            float a = maxReachedDepth / float(maxDepth);
            vec3 color = vec3(a, 0, 0);
            saveResult(color);
            break;
        }
        case VISU_DEPTH_AVERAGE:
        {
            float a = depthSum / float(depthsCounter) / float(maxDepth);
            vec3 color = vec3(a, 0, 0);
            saveResult(color);
            break;
        }
        case VISU_SPLITS:
        {
            float a = nextSplitSlot / float(MAX_SPLITS);
            vec3 color = vec3(a, 0, 0);
            saveResult(color);
            break;
        }
        case VISU_ESTIMATE:
        {
            saveResult(estimate);
            break;
        }
        case VISU_GUIDING_REGIONS:
        {
            saveResult(getGuidingRegionVisualization(pixelCenter));
            break;
        }
        case VISU_GUIDING_OVERLAY:
        {
            vec3 guidingColor;
            float maxT = pushC.guidingVisuIgnoreOcclusioon ? tMax : firstT;

            if (getGuidingDistributionVisualization(pixelCenter, maxT, -1, guidingColor)) {
                saveResult(guidingColor);
            } else {
                saveResult(result);
            }
            break;
        }
        case VISU_GUIDING_ACTIVE_COMPONENTS:
        {
            saveResult(getGuidingActiveComponentsVisualization(pixelCenter));
            break;
        }
        case VISU_GUIDING_PIP:
        {
            const float pipSize = pushC.guidingPiPSize;
            int iRegion = pushC.guidingPiPHighlightRegion % pushC.numGuidingRegions;

            if (gl_LaunchIDEXT.x > gl_LaunchSizeEXT.x * (1.0 - pipSize) && gl_LaunchIDEXT.y > gl_LaunchSizeEXT.y * (1.0 - pipSize)) {
                // PiP mode
                vec2 newCoord = (gl_LaunchIDEXT.xy - gl_LaunchSizeEXT.xy * (1.0 - pipSize)) / (gl_LaunchSizeEXT.xy * pipSize);

                // Center for guiding visu sphere
                aabb bb = guidingAabbs[iRegion];
                vec3 extent = bb.max - bb.min;
                float radius = min(extent.x, min(extent.y, extent.z)) * 0.5 * pushC.guidingVisuScale;

                vec3 center;
                if (pushC.guidingVisuMove) {
                    center = getVisuCenter(pushC.time, pushC.guidingVisuPhiScale, pushC.guidingVisuThetaScale, bb, radius);
                } else {
                    center = bb.min + 0.5 * extent;
                }

                // Direction is coordinate dependent
                vec3 direction = sphericalToCartesian(newCoord.y * M_PI, newCoord.x * 2 * M_PI);

                // VMM value
                VMM_Theta vmmTheta = guidingVMM[iRegion];
                float value = VMM(direction, vmmTheta, center, pushC.useParallaxCompensation);

                // Normalize to range [0,1]
                value = min(1.0, value / pushC.guidingVisuMax);

                saveResult(colormapGuiding(value));
            } else {
                // Normal mode
                if (pushC.guidingPiPShowSpheres) {
                    vec3 guidingColor;
                    float maxT = pushC.guidingVisuIgnoreOcclusioon ? tMax : firstT;

                    if (getGuidingDistributionVisualization(pixelCenter, maxT, iRegion, guidingColor)) {
                        saveResult(guidingColor);
                    } else {
                        saveResult(result);
                    }
                } else {
                    saveResult(result);
                }
            }
            break;
        }
    }

    // Create IC entries
    for (int i = 0; i < nextNewIrradianceCacheSlot; i++) {
        newIrradianceCacheInfo newCacheInfo = newIrradianceCacheEntries[i];

        vec3 color;
        createIrradianceCache(newCacheInfo.origin, newCacheInfo.normal, color);
    }
}