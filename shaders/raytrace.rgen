#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable

#include "raycommon.glsl"
#include "wavefront.glsl"
#include "transform.glsl"
#include "random.glsl"

#define M_PI 3.1415926535897932384626433832795
#define M_INV_2PI 1.0 / (2 * M_PI)
#define E 2.7182818284590452353602874713527

#define MAT_DIFFUSE 0
#define MAT_SPECULAR 1
#define MAT_DIELECTRIC 2
#define MAT_LIGHT 3
#define MAT_PHONG 4
#define MAT_CONDUCTOR 5
#define MAT_ROUGH_CONDUCTOR 6

#define MAX_DISCRETE_FOLLOW 5

#define SIZE_LIGHT_RANDOM 10000
#define SIZE_TRI_RANDOM 10000


const float tMin = 0.001;
const float tMax = 1000000.0;


const uint rayFlags = 0;
const uint shadowRayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;

//@formater:off
layout(push_constant)
uniform PushConstant{ pushConstant pushC; };

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;


layout(binding = 1, set = 1, std140) buffer Vertices{ Vertex v[]; } vertices[];
layout(binding = 2, set = 1) buffer Indices{ uint i[]; } indices[];
layout(binding = 3, set = 1, std430) buffer Materials{ Material mats[]; };
layout(binding = 4, set = 1, std140) buffer Instances{ InstanceInfo instanceInfos[]; };
layout(binding = 5, set = 1, std140) buffer LightsBuffer{ int lightCount; Light lights[]; };
layout(binding = 6, set = 1, std430) buffer LightSamplerBuffer{
    int randomLigthIndex[SIZE_LIGHT_RANDOM];
    FaceSample randomTriIndex[][SIZE_TRI_RANDOM];// access index is the one returned from randomLightIndex, as point lights come after area lights
};

layout(binding = 8, set = 1, std430) buffer Spheres { sphere spheres[]; };
layout(binding = 7, set = 1) uniform sampler2D textureSamplers[];
layout(binding = 9, set = 1, rgba32f) uniform image2D accumulateImage;
layout(binding = 10, set = 1, scalar) buffer UpdateCommands { updateCommandsHeader header;
    updateCommand commands[]; };
layout(binding = 11, set = 1) uniform accelerationStructureEXT irradianceAS;
layout(binding = 12, set = 1, std430) buffer CacheSpheres { sphere cacheSpheres[]; };
layout(binding = 13, set = 1, scalar) buffer Cache { cacheData cache[]; };

layout(binding = 0, set = 1)
uniform CameraMatrices{
    mat4 view;
    mat4 proj;
    mat4 viewInverse;
    mat4 projInverse;
} cam;

layout(location = 0) rayPayloadEXT hitInfo info;
layout(location = 1) rayPayloadEXT shadowCheck shadowInfo;
layout(location = 2) rayPayloadEXT hitInfo infoIrradiance;
//@formatter:on


// Rendering Vorlesung - Nori src/common.cpp
float fresnel(in float eta, in float cosThetaI) {
    float sinThetaSqr = eta * eta * (1 - cosThetaI * cosThetaI);

    if (sinThetaSqr > 1.0f) {
        return 1.0f;// Total internal reflection
    }

    float cosThetaT = sqrt(1.0f - sinThetaSqr);

    float Rs = (eta * cosThetaI - cosThetaT)
    / (eta * cosThetaI + cosThetaT);
    float Rp = (cosThetaI - eta * cosThetaT)
    / (cosThetaI + eta * cosThetaT);

    return (Rs * Rs + Rp * Rp) / 2.0f;
}

// Rendering Vorlesung - Nori src/common.cpp
float fresnelConductor(in float cosThetaI, in float eta, in float k) {
    if (cosThetaI < 0.0f) {
        cosThetaI = -cosThetaI;
    }

    // via http://web.cse.ohio-state.edu/~parent.1/classes/782/Lectures/05_Reflectance_Handout.pdf, slide "Fresnel Reflection - Conductor"
    float Rs2 = ((eta * eta + k * k) * cosThetaI * cosThetaI - 2 * eta * cosThetaI + 1)
    / ((eta * eta + k * k) * cosThetaI * cosThetaI + 2 * eta * cosThetaI + 1);
    float Rp2 = ((eta * eta + k * k) - 2 * eta * cosThetaI + cosThetaI * cosThetaI)
    / ((eta * eta + k * k) + 2 * eta * cosThetaI + cosThetaI * cosThetaI);

    return (Rs2 + Rp2) / 2.0f;
}


// Beckmann Distribution https://www.graphics.cornell.edu/~bjw/microfacetbsdf.pdf
float D(in Material mat, in vec3 n, in vec3 m) {
    float cosTheta = dot(n, m);

    if (cosTheta <= 0) {
        return 0.0;
    }

    float theta = acos(cosTheta);
    float thanTheta = tan(theta);

    float alphaSqr = (mat.roughness * mat.roughness);

    return pow(E, - thanTheta * thanTheta / alphaSqr) / (M_PI * alphaSqr * pow(cosTheta, 4));
}

float G1(in Material mat, in vec3 n, in vec3 m, in vec3 v) {
    float thetaV = dot(v, n);
    float c = dot(v, m) / thetaV;

    if (c <= 0) {
        return 0;
    }


    float a = 1.0 / (mat.roughness * tan(thetaV));

    if (a >= 1.6) {
        return 1.0;
    } else {
        float a2 = a * a;
        return (3.535 * a + 2.181 * a2)/(1 + 2.276 * a + 2.577 * a);
    }

}

float G(in Material mat, in vec3 i, in vec3 o, in vec3 n, in vec3 m) {
    return G1(mat, n, m, i) * G1(mat, n, m, o);
}

// Energy conserving phong method (Lewis ?)
vec3 phong(in Material mat, in vec2 uv, in vec3 normal, in vec3 wi, in vec3 wo) {
    vec3 res = vec3(0.0, 0.0, 0.0);

    float cosThetaWo = dot(wo, normal);
    if (cosThetaWo > 0) {
        if (mat.textureIdDiffuse != -1) {
            res += mat.diffuse * texture(textureSamplers[mat.textureIdDiffuse], info.textureUV).xyz /
            M_PI;
        } else {
            res += mat.diffuse / M_PI;
        }

        float dotReflDir = dot(reflect(-wo, normal), wi);
        if (dotReflDir > 0) {
            if (mat.textureIdSpecular != -1) {
                res += (mat.specularHighlight + 2) / (2 * M_PI) * mat.specular * pow(dotReflDir, mat.specularHighlight) *
                texture(textureSamplers[mat.textureIdSpecular], info.textureUV).xyz;
            } else {
                res += (mat.specularHighlight + 2) / (2 * M_PI) * mat.specular * pow(dotReflDir, mat.specularHighlight);
            }
        }

    }

    return cosThetaWo * res;
}

vec3 roughConductor(in Material mat, in vec3 normal, in vec3 wi, in vec3 wo) {
    vec3 hr = normalize(wi + wo);
    float cosThetaIHr = dot(wi, hr);
    float cosThetaI = dot(wi, normal);
    float cosThetaO = dot(wo, normal);

    return (fresnelConductor(cosThetaIHr, mat.eta, mat.k) * G(mat, wi, wo, normal, hr) * D(mat, normal, hr) / (4 * cosThetaI * cosThetaO)).xxx;
}



float pdfBSDF(in Material mat, in vec3 normal, in vec3 wi, in vec3 wo) {
    switch (mat.type) {
        case MAT_ROUGH_CONDUCTOR:
        vec3 hr = normalize(wi + wo);
        float pm = D(mat, normal, hr);

        if (pm == 0) {
            return 0.0;
        }

        return pm / (4 * dot(wo, hr));

        case MAT_PHONG:// Phong
        if (dot(normal, wo) < 0) {
            // Absorb rays below surface
            return 0.0;
        }

        float lDiffuse = length(mat.diffuse);
        float lSpecular = length(mat.specular);
        float sumSpecDiff = lDiffuse + lSpecular;

        // Completely black objects would produce NaN otherwise
        if (sumSpecDiff == 0) {
            return 0.0;
        }


        // Combine the probabilities of the two sampling methods
        // Cosine power/phong lobe
        vec3 reflected = reflect(-wi, normal);
        float highlight = mat.specularHighlight;

        float pdf = 0;
        if (dot(reflected, wo) > 0) {
            pdf = (highlight + 1) * pow(dot(reflected, wo), highlight) / (2 * M_PI);
            pdf *= lSpecular / sumSpecDiff;
        }

        // Cosine Hemisphere
        pdf += dot(wo, normal) / M_PI * lDiffuse / sumSpecDiff;

        return pdf;

        case MAT_DIFFUSE:// Cosine Hemisphere
        default :
        return dot(wo, normal) / M_PI;
    }
}

float pdfLight(in Light light, in vec3 lightDir, in vec3 lightNormal, in float lightDistance) {
    float cosThetaLight = dot(-lightDir, lightNormal);

    return light.sampleProb * lightDistance * lightDistance /
    cosThetaLight / light.area;
}

float powerHeuristic(in float pdf1, in float pdf2) {
    float sqr_p1 = pdf1 * pdf1;
    return sqr_p1 / (sqr_p1 + pdf2 * pdf2);
}

/**
 * Select a random light and a position on it
 * @param vec3
 * @param vec3
 * @param vec3
 * @param lightDistance
 * @return
 */
float sampleLights(in vec3 origin, in vec3 normal, out vec3 lightDir, out vec3 lightColor, out float lightDistance) {
    // Next event estimation
    // Sample random light

    int iRandomLight;
    int iLight;
    Light light;

    iRandomLight = getRandomInteger(SIZE_LIGHT_RANDOM - 1);

    iLight = randomLigthIndex[iRandomLight];
    light = lights[iLight];

    if (light.isPointLight) {
        // Point light
        vec3 toLight = light.pos - origin;
        lightDistance = length(toLight);
        lightDir = toLight / lightDistance;

        lightColor = light.color / (lightDistance * lightDistance);
        return light.sampleProb;
    } else if (light.isSphere) {
        // Sphere
        sphere s = spheres[light.instanceIndex];

        lightColor = mats[s.materialIndex].lightColor;


        vec3 normal;
        vec3 position = randomOnSphere(s, normal);
        vec3 toLight = position - origin;

        lightDistance = length(toLight);
        lightDir = normalize(toLight);

        float cosThetaLight = dot(-lightDir, normal);

        return light.sampleProb * lightDistance * lightDistance /
        cosThetaLight / light.area;
    }  else if (light.isEnvMap) {
        // Env Map
        vec3 lightDir = randomInHemisphere(normal);


        float atan = atan(lightDir.x, -lightDir.z);
        float u = atan * M_INV_2PI;
        float v = acos(lightDir.y) / M_PI;

        vec2 envMapUV = vec2(u, v);
        lightColor = texture(textureSamplers[0], envMapUV).xyz;
        lightDistance = tMax;

        return light.sampleProb * 2 * M_PI;
    } else {
        // Area light
        int iModel = instanceInfos[light.instanceIndex].modelIndex;

        int iRandomTri = getRandomInteger(SIZE_TRI_RANDOM - 1);
        FaceSample triSample = randomTriIndex[iLight][iRandomTri];

        int iTri = triSample.index;

        ivec3 ind = ivec3(indices[iModel].i[3 * iTri + 0], //
        indices[iModel].i[3 * iTri + 1], //
        indices[iModel].i[3 * iTri + 2]);//

        // Vertex of the triangle
        Vertex v0 = vertices[iModel].v[ind.x];
        Vertex v1 = vertices[iModel].v[ind.y];
        Vertex v2 = vertices[iModel].v[ind.z];

        // Uniform random point on triangle
        vec2 randomXY = vec2(rnd(), rnd());
        float sqrtx = sqrt(randomXY.x);
        float sqrty = sqrt(randomXY.y);
        vec3 barycentrics = vec3(1.0 - sqrtx, sqrtx * (1.0 - randomXY.y), randomXY.y * sqrtx);

        // Computing the coordinates of the hit position
        vec3 lightSampleWorldPos = v0.pos * barycentrics.x + v1.pos * barycentrics.y + v2.pos * barycentrics.z;
        vec3 lightSampleNormal = v0.normal * barycentrics.x + v1.normal * barycentrics.y + v2.normal * barycentrics.z;

        // Transforming the position and normal to world space
        mat4 transform = instanceInfos[light.instanceIndex].transform;
        mat4 normalTransform = instanceInfos[light.instanceIndex].normalTransform;
        lightSampleWorldPos = (transform * vec4(lightSampleWorldPos, 1.0)).xyz;
        lightSampleNormal = (normalTransform * vec4(lightSampleNormal, 0.0)).xyz;

        // Normalize normal, because scaling
        lightSampleNormal = normalize(lightSampleNormal);

        vec3 toLight = lightSampleWorldPos - origin;
        lightDistance = length(toLight);
        lightDir = toLight / lightDistance;

        lightColor = mats[v0.materialIndex].lightColor;

        float cosThetaLight = dot(-lightDir, lightSampleNormal);

        return light.sampleProb * lightDistance * lightDistance /
        cosThetaLight / light.area;
    }
}

/**
 *
 * @param Material
 * @param vec3
 * @param vec3
 * @param vec3
 * @return pdf
 */
float sampleBSDF(in Material mat, in vec3 direction, in vec3 normal, in bool frontFace, out vec3 newDirection) {
    switch (mat.type) {
        case MAT_ROUGH_CONDUCTOR:
        vec3 worldM = randomBeckmannNormal(mat, normal);

        newDirection = reflect(direction, worldM);

        return pdfBSDF(mat, normal, -direction, newDirection);

        case MAT_PHONG:
        float lDiffuse = length(mat.diffuse);
        float lSpecular = length(mat.specular);
        float sumSpecDiff = lDiffuse + lSpecular;

        // Completely black objects would produce NaN otherwise
        if (sumSpecDiff == 0) {
            return 0.0;
        }

        float pdf;
        if (rnd() * sumSpecDiff > lDiffuse) {
            // Cosine power/phong lobe
            vec3 reflected = reflect(direction, normal);

            float highlight = mat.specularHighlight;
            newDirection = randomInHemisphereCosinePower(reflected, highlight);

            if (dot(normal, newDirection) < 0) {
                // Absorb rays below surface
                return 0.0;
            }

            return pdfBSDF(mat, normal, -direction, newDirection);
        } else {
            // Cosine Hemisphere
            newDirection = randomInHemisphereCosine(normal);
            return pdfBSDF(mat, normal, -direction, newDirection);
        }


        case MAT_SPECULAR:
        case MAT_CONDUCTOR:
        newDirection = reflect(direction, normal);
        return 1.0;

        case MAT_DIELECTRIC:
        float eta = mat.refractionIndexInv;

        if (!frontFace) {
            eta = mat.refractionIndex;
        }
        float cosTheta = dot(-direction, normal);
        float fresnel = fresnel(eta, cosTheta);

        if (rnd() > fresnel) {
            // Refract
            newDirection = refract(direction, normal, eta);
            return 1.0 - fresnel;
        } else {
            // Reflect
            newDirection = reflect(direction, normal);
            return fresnel;
        }

        case MAT_DIFFUSE:
        default :
        // Cosine Hemisphere
        newDirection = randomInHemisphereCosine(normal);
        return dot(newDirection, normal) / M_PI;
    }
}

/**
 * For discrete direction material, assume that wo is one of the correct directions
 */
vec3 evalBsdf(Material mat, vec2 uv, vec3 normal, vec3 wi, vec3 wo, bool frontFace) {
    switch (mat.type) {
        case MAT_DIFFUSE:
        case MAT_PHONG:
        case MAT_LIGHT:
        return phong(mat, uv, normal, wi, wo);

        case MAT_ROUGH_CONDUCTOR:
        return roughConductor(mat, normal, wi, wo);

        case MAT_DIELECTRIC:
        {
            float cosTheta = dot(normal, wo);

            float eta = mat.refractionIndexInv;

            if (!frontFace) {
                eta = mat.refractionIndex;
            }

            if (cosTheta < 0) {
                // Refraction
                return mat.specular * (1 - fresnel(eta, cosTheta));
            } else {
                // Reflect
                return mat.specular * fresnel(eta, cosTheta);
            }
        }
        case MAT_CONDUCTOR:
        {
            float cosTheta = dot(wi, normal);
            return fresnelConductor(cosTheta, mat.eta, mat.k).xxx;
        }
        case MAT_SPECULAR:
        return mat.specular;

        default :
        return vec3(0, 0, 0);
    }
}

vec3 nextEventEstimation(Material mat, vec3 origin, vec3 direction, vec3 normal) {
    switch (mat.type) {
        case MAT_DIFFUSE:
        case MAT_PHONG:
        case MAT_LIGHT:
        case MAT_ROUGH_CONDUCTOR:
        break;
        default :
        // Only run NEE for those materials that are supported
        return vec3(0, 0, 0);
    }

    vec3 neeResult = vec3(0, 0, 0);

    // Sample random light
    vec3 lightDir;
    vec3 lightColor;
    float lightDistance;
    float pdfLights = sampleLights(origin, normal, lightDir, lightColor, lightDistance);

    vec2 textureUV = info.textureUV;

    // Check if shadowed
    shadowInfo.isShadowed = true;
    if (dot(lightDir, normal) > 0) {
        traceRayEXT(topLevelAS, // acceleration structure
        shadowRayFlags, // rayFlags
        0xFF, // cullMask
        0, // sbtRecordOffset
        0, // sbtRecordStride
        1, // missIndex of shadow miss
        origin.xyz, // ray origin
        tMin, // ray min range
        lightDir, // ray direction
        lightDistance - 0.0001, // ray max range
        1// payload (location = 1)
        );
    }

    if (!shadowInfo.isShadowed) {
        if (pushC.enableMIS) {
            // MIS
            float pdfMat = pdfBSDF(mat, normal, -direction, lightDir);
            neeResult += evalBsdf(mat, textureUV, normal, -direction, lightDir, info.isFrontFace) *
            lightColor * powerHeuristic(pdfLights, pdfMat) / pdfLights;
        } else {
            neeResult = evalBsdf(mat, textureUV, normal, -direction, lightDir, info.isFrontFace)
            * lightColor / pdfLights;
        }
    }

    if (pushC.enableMIS) {
        // Direct light check with BSDF sample
        vec3 bsdfDir;
        float pdfMat = sampleBSDF(mat, direction, normal, info.isFrontFace, bsdfDir);

        if (pdfMat > 0)  {
            traceRayEXT(topLevelAS, // acceleration structure
            rayFlags, // rayFlags
            0xFF, // cullMask
            0, // sbtRecordOffset
            0, // sbtRecordStride
            0, // missIndex
            origin.xyz, // ray origin
            tMin, // ray min range
            bsdfDir, // ray direction
            tMax, // ray max range
            0// payload (location = 0)
            );

            // Check if a light was hit at all
            Material matSample = mats[info.matIndex];
            if (!info.isMiss && matSample.type == 3) {
                int iLight = instanceInfos[info.instanceIndex].iLight;
                Light light = lights[iLight];

                lightColor = matSample.lightColor;
                pdfLights = pdfLight(light, bsdfDir, info.normal, info.t);

                neeResult += evalBsdf(mat, textureUV, normal, -direction, bsdfDir, info.isFrontFace) *
                lightColor * powerHeuristic(pdfMat, pdfLights) / pdfMat;
            }


        }
    }
    return neeResult;
}

bool hasDiscreteDirection(Material mat) {
    switch (mat.type) {
        case MAT_DIELECTRIC:
        case MAT_SPECULAR:
        case MAT_CONDUCTOR:
        return true;
        default :
        return false;
    }
}

void calculateCacheData(in vec3 origin, in vec3 normal, uint cacheIndex) {
    const int n = 10;
    cache[cacheIndex].normal = normal;

    vec3 color = vec3(0, 0, 0);
    for (int j = 1; j < n; j++) {
        for (int k = 1; k < 2 * n; k++) {
            float theta = asin(sqrt((j - rnd()) / n));
            float phi = M_PI * (k - rnd()) / n;

            vec3 direction = toWorld(sphericalToCartesian(theta, phi), normal);

            bool follow = true;
            int followCount = 0;

            vec3 throughput = vec3(1.0, 1.0, 1.0);

            do {
                traceRayEXT(topLevelAS, // acceleration structure
                rayFlags, // rayFlags
                0xFF, // cullMask
                0, // sbtRecordOffset
                0, // sbtRecordStride
                0, // missIndex
                origin.xyz, // ray origin
                tMin, // ray min range
                direction.xyz, // ray direction
                10, // ray max range
                0// payload (location = 0)
                );


                if (info.isMiss) {
                    color += throughput * info.missColor;
                    follow = false;
                } else {
                    Material mat = mats[info.matIndex];
                    origin = info.worldPos;
                    normal = info.normal;
                    if (hasDiscreteDirection(mat)) {
                        vec3 newDirection;
                        float pdf = sampleBSDF(mat, direction, normal, info.isFrontFace, newDirection);

                        if (pdf <= 0.0) {
                            break;
                        }

                        throughput *= evalBsdf(mat, info.textureUV, normal, -direction, newDirection, info.isFrontFace) / pdf;

                        direction = newDirection;
                        followCount++;
                    } else {
                        for (int i = 0; i < 10; i++) {
                            color += 0.1 * throughput * nextEventEstimation(mat, origin, direction, normal);
                        }
                        follow = false;
                    }
                }
            } while (follow && followCount <= MAX_DISCRETE_FOLLOW);
        }
    }

    cache[cacheIndex].color = color / (2 * n * n);
}

void main() {
    // Init seed
    seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pushC.randomUInt);

    vec3 result = vec3(0.0, 0.0, 0.0);

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);



    const int samplesPerPixel = pushC.samplesPerPixel;
    const int maxDepth = pushC.maxDepth;

    for (int iSample = 0; iSample < samplesPerPixel; ++iSample) {
        vec3 sampleResult = vec3(0.0, 0.0, 0.0);
        vec3 throughput = vec3(1.0, 1.0, 1.0);

        vec2 inUV = (pixelCenter + vec2(getRandomNegPos(), getRandomNegPos()) / 2.0) / vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;

        vec3 origin = (cam.viewInverse * vec4(0, 0, 0, 1)).xyz;
        vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1);
        vec3 direction = normalize((cam.viewInverse * vec4(normalize(target.xyz), 0)).xyz);


        bool addDirectLightHits = true;

        for (int iDepth = 0; iDepth < maxDepth; ++iDepth) {
            traceRayEXT(topLevelAS, // acceleration structure
            rayFlags, // rayFlags
            0xFF, // cullMask
            0, // sbtRecordOffset
            0, // sbtRecordStride
            0, // missIndex
            origin.xyz, // ray origin
            tMin, // ray min range
            direction.xyz, // ray direction
            tMax, // ray max range
            0// payload (location = 0)
            );

            if (pushC.showIrradianceCache && iDepth == 0) {
                traceRayEXT(irradianceAS, // acceleration structure
                rayFlags, // rayFlags
                0xFF, // cullMask
                0, // sbtRecordOffset
                0, // sbtRecordStride
                0, // missIndex
                origin.xyz, // ray origin
                tMin, // ray min range
                direction.xyz, // ray direction
                info.t, // ray max range
                2// payload (location = 2)
                );

                if (!infoIrradiance.isMiss) {
//                    if (dot(direction, cache[infoIrradiance.instanceIndex].normal) > 0) {
//                        result = vec3(1, 0, 0);
//                        iSample = samplesPerPixel;
//                        break;
//                    }

                    result = cache[infoIrradiance.instanceIndex].color * dot(infoIrradiance.normal, -direction);
                    iSample = samplesPerPixel;
                    break;
                }
            }


            // Miss => Directional light / skybox
            if (info.isMiss) {
                sampleResult += throughput * info.missColor;
                break;
            }

            origin = info.worldPos;

            Material mat = mats[info.matIndex];
            vec3 normal = info.normal;
            vec2 textureUV = info.textureUV;
            float cosThetaWi = -dot(direction, normal);

            if (pushC.enableNEE) {
                sampleResult += throughput * nextEventEstimation(mat, origin, direction, normal);
            }

            switch (mat.type) {
                case MAT_LIGHT:// Light
                if (!pushC.enableNEE || addDirectLightHits) {
                    sampleResult += throughput * mat.lightColor;
                }
                // Then continue as diffuse
                case MAT_DIFFUSE:// Diffuse
                if (rnd() < 0.000001) {
                    uint iCommand = atomicAdd(header.nextCommandSlot, 1);

                    if (iCommand < header.maxCommands) {
                        header.nextCommandSlot += 1;
                        commands[iCommand].center = origin;
                        commands[iCommand].radius = 0.1;
                        commands[iCommand].isFilled = true;

                        uint iCache = atomicAdd(header.nextSphereSlot, 1);
                        commands[iCommand].iSphere = iCache;

                        calculateCacheData(origin, normal, iCache);
                    }
                }

                case MAT_PHONG:// Phong
                vec3 newDirection;
                float pdf = sampleBSDF(mat, direction, normal, info.isFrontFace, newDirection);

                // Absorbed rays
                if (pdf == 0) {
                    iDepth = maxDepth + 1;
                    break;
                }

                throughput *= phong(mat, textureUV, normal, -direction, newDirection) / pdf;

                direction = newDirection;
                addDirectLightHits = false;
                break;
                case MAT_SPECULAR:// Specular
                {
                    throughput *= mat.specular;

                    direction = reflect(direction, normal);
                    addDirectLightHits = true;
                    break;
                }

                case MAT_DIELECTRIC:// Transparent
                {
                    throughput *= mat.specular;

                    float eta = mat.refractionIndexInv;

                    if (!info.isFrontFace) {
                        eta = mat.refractionIndex;
                    }
                    float cosTheta = dot(-direction, normal);
                    float fresnel = fresnel(eta, cosTheta);

                    if (rnd() > fresnel) {
                        // Refract
                        direction = refract(direction, normal, eta);
                    } else {
                        // Reflect
                        direction = reflect(direction, normal);
                    }

                    addDirectLightHits = true;
                    break;
                }

                case MAT_CONDUCTOR:
                {
                    float cosTheta = dot(-direction, normal);
                    throughput *= fresnelConductor(cosTheta, mat.eta, mat.k);

                    direction = reflect(direction, normal);
                    addDirectLightHits = true;
                    break;
                }

                case MAT_ROUGH_CONDUCTOR:
                {
                    vec3 worldM = randomBeckmannNormal(mat, normal);

                    newDirection = reflect(direction, worldM);

                    float cosThetaIM = dot(-direction, worldM);
                    float cosThetaIN = dot(-direction, normal);
                    float cosThetaNM = dot(normal, worldM);

                    // Eqn 41 https://www.graphics.cornell.edu/~bjw/microfacetbsdf.pdf
                    throughput *= fresnelConductor(cosThetaIM, mat.eta, mat.k) * G(mat, -direction, newDirection, normal, worldM) * cosThetaIM / (cosThetaIN * cosThetaNM);

                    direction = newDirection;
                    addDirectLightHits = true;
                    break;
                }
            }

            if (pushC.enableRR && iDepth > 5) {
                float p = (throughput.x + throughput.y + throughput.z) / 3.0;
                // Russian roulette
                if (rnd() > p) {
                    break;
                } else {
                    throughput *= 1.0 / p;
                }
            }
        }

        result += sampleResult;
    }

    result /= samplesPerPixel;

    ivec2 imageUV = ivec2(gl_LaunchIDEXT.xy);

    if (pushC.enableAverageInsteadOfMix) {
        // if the camera hasn't changed, then accumulate results
        if (pushC.previousFrames > 0) {
            vec3 accumulated = imageLoad(accumulateImage, imageUV).xyz;
            accumulated += result;

            imageStore(image, imageUV, vec4(accumulated / (pushC.previousFrames + 1), 1.0));
            imageStore(accumulateImage, imageUV, vec4(accumulated, 1.0));
        } else {
            imageStore(accumulateImage, imageUV, vec4(result, 1.0));
            imageStore(image, imageUV, vec4(result, 1.0));
        }
    } else {
        // if the camera hasn't changed, then mix with previous results
        if (pushC.previousFrames > 0) {
            vec3 previous = imageLoad(image, imageUV).xyz;
            result = mix(previous, result, 1.0 / (pushC.previousFrames + 1));

            imageStore(image, imageUV, vec4(result, 1.0));
        } else {
            imageStore(image, imageUV, vec4(result, 1.0));
        }
    }

}