#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "raycommon.glsl"
#include "wavefront.glsl"
#include "random.glsl"

#define M_PI 3.1415926535897932384626433832795
#define SIZE_LIGHT_RANDOM 10000
#define SIZE_TRI_RANDOM 10000

layout(push_constant)
uniform PushConstant{pushConstant pushC;};

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;


layout(binding = 1, set = 1, std140) buffer Vertices{Vertex v[];} vertices[];
layout(binding = 2, set = 1) buffer Indices{uint i[];} indices[];
layout(binding = 3, set = 1, std430) buffer Materials{Material mats[];};
layout(binding = 4, set = 1, std140) buffer Instances{InstanceInfo instanceInfos[];};
layout(binding = 5, set = 1, std140) buffer LightsBuffer{int lightCount; Light lights[];};
layout(binding = 6, set = 1, std430) buffer LightSamplerBuffer{
        int randomLigthIndex[SIZE_LIGHT_RANDOM];
        FaceSample randomTriIndex[][SIZE_TRI_RANDOM]; // access index is the one returned from randomLightIndex, as point lights come after area lights
};

layout(binding = 7, set = 1
)
uniform sampler2D
textureSamplers[];
layout(binding = 8, set = 1, rgba32f
)
uniform image2D
accumulateImage;


layout(binding = 0, set = 1
)
uniform CameraMatrices{
        mat4 view;
        mat4 proj;
        mat4 viewInverse;
        mat4 projInverse;
}
cam;

layout(location = 0
)
rayPayloadEXT hitInfo
info;
layout(location = 1
)
rayPayloadEXT shadowCheck
shadowInfo;

uint seed;

// Random float [-1, 1)
float getRandomNegPos() {
    return rnd(seed) * 2 - 1;
}

// Random int [0, max]
int getRandomInteger(int max) {
    return int(rnd(seed) * (max + 1));
}

// Rendering Vorlesung - Nori src/common.cpp
void coordinateAxis(in vec3 z, out vec3 x, out vec3 y) {
    if (abs(z.x) > abs(z.y)) {
        float invLen = 1.0f / sqrt(z.x * z.x + z.z * z.z);
        y = vec3(z.z * invLen, 0.0f, -z.x * invLen);
    } else {
        float invLen = 1.0f / sqrt(z.y * z.y + z.z * z.z);
        y = vec3(0.0f, z.z * invLen, -z.y * invLen);
    }
    x = cross(y, z);
}

vec3 toLocal(vec3 v, vec3 x, vec3 y, vec3 z) {
    return vec3(dot(v, x), dot(v, y), dot(v, z));
}

vec3 toLocal(vec3 v, vec3 n) {
    vec3 x, y;
    coordinateAxis(n, x, y);

    return toLocal(v, x, y, n);
}

vec3 toWorld(vec3 v, vec3 x, vec3 y, vec3 z) {
    return v.x * x + v.y * y + v.z * z;
}

vec3 toWorld(vec3 v, vec3 n) {
    vec3 x, y;
    coordinateAxis(n, x, y);

    return toWorld(v, x, y, n);
}

// https://math.stackexchange.com/a/1163278
vec3 randomOnUnitSphere() {
    vec3 res;
    do {
        res = vec3(rnd(seed), rnd(seed), rnd(seed));
    } while (length(res) > 1);

    res = normalize(res);
    return res;
}

// PDF 1 / (2pi)
vec3 randomInHemisphere(vec3 normal) {
    vec3 res;
    do {
        res = vec3(getRandomNegPos(), getRandomNegPos(), getRandomNegPos());
    } while (length(res) > 1);

    res = normalize(res);

    if (dot(normal, res) < 0) {
        res = res - normal * 2 * dot(normal, res);
    }
    return res;
}

// PDF cos(theta) / pi
vec3 randomInHemisphereCosine(vec3 normal) {
    float u = rnd(seed);
    float sqrt_u = sqrt(u);
    float phi = 2 * M_PI * rnd(seed);

    vec3 local = vec3(sqrt_u * cos(phi), sqrt_u * sin(phi), sqrt(1 - u));

    return toWorld(local, normal);
}

// (p + 1) * dot(reflected, res)^p/(2pi)
vec3 randomInHemisphereCosinePower(vec3 reflected, float p) {
    float u = rnd(seed);
    float cosTheta = pow(u, 1.0 / (p + 1));
    float phi = 2 * M_PI * rnd(seed);

    float sinTheta = sqrt(1 - cosTheta * cosTheta);

    vec3 local = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
    return toWorld(local, reflected);
}

// Rendering Vorlesung - Nori src/common.cpp
float fresnel(in float eta, in float cosThetaI) {
    float sinThetaSqr = eta * eta * (1 - cosThetaI * cosThetaI);

    if (sinThetaSqr > 1.0f) {
        return 1.0f; // Total internal reflection
    }

    float cosThetaT = sqrt(1.0f - sinThetaSqr);

    float Rs = (eta * cosThetaI - cosThetaT)
               / (eta * cosThetaI + cosThetaT);
    float Rp = (cosThetaI - eta * cosThetaT)
               / (cosThetaI + eta * cosThetaT);

    return (Rs * Rs + Rp * Rp) / 2.0f;
}

// Energy conserving phong method (Lewis ?)
vec3 phong(in Material mat, in vec2 uv, in vec3 normal, in vec3 wi, in vec3 wo) {
    vec3 res = vec3(0.0, 0.0, 0.0);

    float cosThetaWo = dot(wo, normal);
    if (cosThetaWo > 0) {
        if (mat.textureIdDiffuse != -1) {
            res += mat.diffuse * texture(textureSamplers[mat.textureIdDiffuse], info.textureUV).xyz /
                   M_PI;
        } else {
            res += mat.diffuse / M_PI;
        }

        float dotReflDir = dot(reflect(-wo, normal), wi);
        if (dotReflDir > 0) {
            if (mat.textureIdSpecular != -1) {
                res += (mat.specularHighlight + 2) / (2 * M_PI) * mat.specular * pow(dotReflDir, mat.specularHighlight) *
                       texture(textureSamplers[mat.textureIdSpecular], info.textureUV).xyz;
            } else {
                res += (mat.specularHighlight + 2) / (2 * M_PI) * mat.specular * pow(dotReflDir, mat.specularHighlight);
            }
        }

    }

    return cosThetaWo * res;
}

float pdfBSDF(in Material mat, in vec3 wi, in vec3 normal, in vec3
              wo) { // TODO: wi wo renaming for defined directions
    switch (pushC.diffuseSampleStrategy) {
        case 0: // Uniform Hemisphere
            return 1.0 / (2 * M_PI);
        case 1: // Cosine Hemisphere
            return dot(wo, normal) / M_PI;
        case 2: // Phong
        default:
            if (dot(normal, wo) < 0) {
                // Absorb rays below surface
                return 0.0;
            }

            float lDiffuse = length(mat.diffuse);
            float lSpecular = length(mat.specular);
            float sumSpecDiff = lDiffuse + lSpecular;

            // Completely black objects would produce NaN otherwise
            if (sumSpecDiff == 0) {
                return 0.0;
            }


            // Combine the probabilities of the two sampling methods
            // Cosine power/phong lobe
            vec3 reflected = reflect(-wi, normal);
            float highlight = mat.specularHighlight;

            float pdf = 0;
            if (dot(reflected, wo) > 0) {
                pdf = (highlight + 1) * pow(dot(reflected, wo), highlight) / (2 * M_PI);
                pdf *= lSpecular / sumSpecDiff;
            }

            // Cosine Hemisphere
            pdf += dot(wo, normal) / M_PI * lDiffuse / sumSpecDiff;

            return pdf;
    }
}

float pdfLight(in Light light, in vec3 lightDir, in vec3 lightNormal, in float lightDistance) {
    float cosThetaLight = dot(-lightDir, lightNormal);

    return light.sampleProb * lightDistance * lightDistance /
           cosThetaLight / light.area;
}

float powerHeuristic(in float pdf1, in float pdf2) {
    float sqr_p1 = pdf1 * pdf1;
    return sqr_p1 / (sqr_p1 + pdf2 * pdf2);
}

/**
 * Select a random light and a position on it
 * @param vec3
 * @param vec3
 * @param vec3
 * @param lightDistance
 * @return
 */
float sampleLights(in vec3 origin, out vec3 lightDir, out vec3 lightColor, out float lightDistance) {
    // Next event estimation
    // Sample random light

//                        // A single light should not interact with itself
//                        if (mat.type == 3 && lightCount == 1) {
//                            break;
//                        }

    int iRandomLight;
    int iLight;
    Light light;

    do {
        iRandomLight = getRandomInteger(SIZE_LIGHT_RANDOM - 1);
        iLight = randomLigthIndex[iRandomLight];
        light = lights[iLight];
    } while (false);//light.instanceIndex == info.instanceIndex && !light.isPointLight); // Don't let light contribute to itself

    if (light.isPointLight) {
        // Point light
        vec3 toLight = light.pos - origin;
        lightDistance = length(toLight);
        lightDir = toLight / lightDistance;

        lightColor = light.color / (lightDistance * lightDistance);
        return light.sampleProb;
    } else {
        // Area light
        int iModel = instanceInfos[light.instanceIndex].modelIndex;

        int iRandomTri = getRandomInteger(SIZE_TRI_RANDOM - 1);
        FaceSample triSample = randomTriIndex[iLight][iRandomTri];

        int iTri = triSample.index;

        ivec3 ind = ivec3(indices[iModel].i[3 * iTri + 0],   //
                          indices[iModel].i[3 * iTri + 1],   //
                          indices[iModel].i[3 * iTri + 2]);  //

        // Vertex of the triangle
        Vertex v0 = vertices[iModel].v[ind.x];
        Vertex v1 = vertices[iModel].v[ind.y];
        Vertex v2 = vertices[iModel].v[ind.z];

        // Uniform random point on triangle
        vec2 randomXY = vec2(rnd(seed), rnd(seed));
        float sqrtx = sqrt(randomXY.x);
        float sqrty = sqrt(randomXY.y);
        vec3 barycentrics = vec3(1.0 - sqrtx, sqrtx * (1.0 - randomXY.y), randomXY.y * sqrtx);

        // Computing the coordinates of the hit position
        vec3 lightSampleWorldPos = v0.pos * barycentrics.x + v1.pos * barycentrics.y + v2.pos * barycentrics.z;
        vec3 lightSampleNormal = v0.normal * barycentrics.x + v1.normal * barycentrics.y + v2.normal * barycentrics.z;

        // Transforming the position and normal to world space
        mat4 transform = instanceInfos[light.instanceIndex].transform;
        mat4 normalTransform = instanceInfos[light.instanceIndex].normalTransform;
        lightSampleWorldPos = (transform * vec4(lightSampleWorldPos, 1.0)).xyz;
        lightSampleNormal = (normalTransform * vec4(lightSampleNormal, 0.0)).xyz;

        vec3 toLight = lightSampleWorldPos - origin;
        lightDistance = length(toLight);
        lightDir = toLight / lightDistance;

        lightColor = mats[v0.materialIndex].lightColor;

        float cosThetaLight = dot(-lightDir, lightSampleNormal);

        return light.sampleProb * lightDistance * lightDistance /
               cosThetaLight / light.area;
    }
}

/**
 *
 * @param Material
 * @param vec3
 * @param vec3
 * @param vec3
 * @return pdf
 */
float sampleBSDF(in Material mat, in vec3 direction, in vec3 normal, out vec3 newDirection) {
    if (pushC.diffuseSampleStrategy == 0) { // TODO: switch case
        // Uniform Hemisphere
        newDirection = randomInHemisphere(normal);
        return 1 / (2 * M_PI);
    } else if (pushC.diffuseSampleStrategy == 1) {
        // Cosine Hemisphere
        newDirection = randomInHemisphereCosine(normal);
        return dot(newDirection, normal) / M_PI;
    } else {
        // Phong
        float lDiffuse = length(mat.diffuse);
        float lSpecular = length(mat.specular);
        float sumSpecDiff = lDiffuse + lSpecular;

        // Completely black objects would produce NaN otherwise
        if (sumSpecDiff == 0) {
            return 0.0;
        }

        float pdf;
        if (rnd(seed) * sumSpecDiff > lDiffuse) {
            // Cosine power/phong lobe
            vec3 reflected = reflect(direction, normal);

            float highlight = mat.specularHighlight;
            newDirection = randomInHemisphereCosinePower(reflected, highlight);

            if (dot(normal, newDirection) < 0) {
                // Absorb rays below surface
                return 0.0;
            }

//            pdf = (highlight + 1) * pow(dot(reflected, newDirection), highlight) / (2 * M_PI);
            return pdfBSDF(mat, -direction, normal, newDirection);// pdf * lSpecular / sumSpecDiff;
        } else {
            // Cosine Hemisphere
            newDirection = randomInHemisphereCosine(normal);
//            pdf = dot(newDirection, normal) / M_PI;
            return pdfBSDF(mat, -direction, normal, newDirection);////pdf * lDiffuse / sumSpecDiff;
        }
    }
}

void main() {
    // Init seed
    seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pushC.randomUInt);

    vec3 result = vec3(0.0, 0.0, 0.0);

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);

    const uint rayFlags = 0;
    const uint shadowRayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;
    const float tMin = 0.001;
    const float tMax = 10000.0;


    const int samplesPerPixel = pushC.samplesPerPixel;
    const int maxDepth = pushC.maxDepth;

    for (int iSample = 0; iSample < samplesPerPixel; ++iSample) {
        vec3 sampleResult = vec3(0.0, 0.0, 0.0);
        vec3 throughput = vec3(1.0, 1.0, 1.0);

        vec2 inUV = (pixelCenter + vec2(getRandomNegPos(), getRandomNegPos()) / 2.0) / vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;

        vec3 origin = (cam.viewInverse * vec4(0, 0, 0, 1)).xyz;
        vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1);
        vec3 direction = (cam.viewInverse * vec4(normalize(target.xyz), 0)).xyz;


        bool addDirectLightHits = true;

        for (int iDepth = 0; iDepth < maxDepth; ++iDepth) {
            traceRayEXT(topLevelAS,     // acceleration structure
                        rayFlags,       // rayFlags
                        0xFF,           // cullMask
                        0,              // sbtRecordOffset
                        0,              // sbtRecordStride
                        0,              // missIndex
                        origin.xyz,     // ray origin
                        tMin,           // ray min range
                        direction.xyz,  // ray direction
                        tMax,           // ray max range
                        0               // payload (location = 0)
            );
            // Miss => Directional light / skybox
            if (info.isMiss) {
                sampleResult += throughput * info.missColor;
                break;
            }

            origin = info.worldPos;

            bool frontFace = true;
            if (dot(direction, info.normal) > 0.0) {
                info.normal = -info.normal;
                frontFace = false;
            }

            Material mat = mats[info.matIndex];
            vec3 normal = info.normal;
            vec2 textureUV = info.textureUV;
            float cosThetaWi = -dot(direction, normal);

            switch (mat.type) {
                case 3: // Light
                    if (!pushC.enableNEE || addDirectLightHits) {
                        sampleResult += throughput * mat.lightColor;
                    }
                    // Then continue as diffuse
                case 0: // Diffuse
                case 4: // Phong

                    if (pushC.enableNEE && lightCount > 0) {
                        // Next event estimation

                        vec3 neeResult = vec3(0, 0, 0);

                        // Sample random light
                        vec3 lightDir;
                        vec3 lightColor;
                        float lightDistance;
                        float pdfLights = sampleLights(origin, lightDir, lightColor, lightDistance);

                        // Check if shadowed
                        shadowInfo.isShadowed = true;
                        if (dot(lightDir, normal) > 0) {
                            traceRayEXT(topLevelAS,     // acceleration structure
                                        shadowRayFlags,       // rayFlags
                                        0xFF,           // cullMask
                                        0,              // sbtRecordOffset
                                        0,              // sbtRecordStride
                                        1,              // missIndex of shadow miss
                                        origin.xyz,     // ray origin
                                        tMin,           // ray min range
                                        lightDir,  // ray direction
                                        lightDistance - 0.0001,           // ray max range
                                        1               // payload (location = 1)
                            );
                        }

                        if (!shadowInfo.isShadowed) {
                            if (pushC.enableMIS) {
                                // MIS
                                float pdfMat = pdfBSDF(mat, -direction, normal, lightDir);
                                neeResult += throughput *
                                             phong(mat, textureUV, normal, -direction, lightDir) *
                                             lightColor * powerHeuristic(pdfLights, pdfMat) / pdfLights;
                            } else {
                                neeResult = throughput * phong(mat, textureUV, normal, -direction, lightDir)
                                            * lightColor / pdfLights;
                            }
                        }

                        if (pushC.enableMIS) {
                            // Direct light check with BSDF sample
                            vec3 bsdfDir;
                            float pdfMat = sampleBSDF(mat, direction, normal, bsdfDir);

                            if (pdfMat > 0)  {
                                traceRayEXT(topLevelAS,     // acceleration structure
                                            rayFlags,       // rayFlags
                                            0xFF,           // cullMask
                                            0,              // sbtRecordOffset
                                            0,              // sbtRecordStride
                                            0,              // missIndex
                                            origin.xyz,     // ray origin
                                            tMin,           // ray min range
                                            bsdfDir,  // ray direction
                                            tMax,           // ray max range
                                            0               // payload (location = 0)
                                );

                                // Check if a light was hit at all
                                Material matSample = mats[info.matIndex];
                                if (!info.isMiss && matSample.type == 3) {
                                    int iLight = instanceInfos[info.instanceIndex].iLight;
                                    Light light = lights[iLight];

                                    lightColor = matSample.lightColor;
                                    pdfLights = pdfLight(light, bsdfDir, info.normal, info.t);

                                    neeResult += throughput *
                                                 phong(mat, textureUV, normal, -direction, bsdfDir) *
                                                 lightColor * powerHeuristic(pdfMat, pdfLights) / pdfMat;
                                }


                            }
                        }


                        sampleResult += neeResult;
                    }

                    vec3 newDirection;
                    float pdf = sampleBSDF(mat, direction, normal, newDirection);

                    // Absorbed rays
                    if (pdf == 0) {
                        iDepth = maxDepth + 1;
                        break;
                    }

                    normal = normalize(normal);
                    direction = normalize(direction);
                    newDirection = normalize(newDirection);

                    throughput *= phong(mat, textureUV, normal, -direction, newDirection) / pdf;

                    direction = newDirection;
                    addDirectLightHits = false;
                    break;
                case 1: // Specular
                {
                    throughput *= mat.specular;

                    direction = reflect(direction, normal);
                    addDirectLightHits = true;
                    break;
                }

                case 2: // Transparent
                {
                    throughput *= mat.specular;

                    float eta = mat.refractionIndexInv;

                    if (!frontFace) {
                        eta = mat.refractionIndex;
                    }
                    float cosTheta = dot(-direction, normal);
                    float fresnel = fresnel(eta, cosTheta);

                    if (rnd(seed) > fresnel) {
                        // Refract
                        direction = refract(direction, normal, eta);
                    } else {
                        // Reflect
                        direction = reflect(direction, normal);
                    }

                    addDirectLightHits = true;
                    break;
                }
            }

            if (pushC.enableRR && iDepth > 5) {
                float p = (throughput.x + throughput.y + throughput.z) / 3.0;
                // Russian roulette
                if (rnd(seed) > p) {
                    break;
                } else {
                    throughput *= 1.0 / p;
                }
            }
        }

        result += sampleResult;
    }

    result /= samplesPerPixel;

    ivec2 imageUV = ivec2(gl_LaunchIDEXT.xy);

    if (pushC.enableAverageInsteadOfMix) {
        // if the camera hasn't changed, then accumulate results
        if (pushC.previousFrames > 0) {
            vec3 accumulated = imageLoad(accumulateImage, imageUV).xyz;
            accumulated += result;

            imageStore(image, imageUV, vec4(accumulated / (pushC.previousFrames + 1), 1.0));
            imageStore(accumulateImage, imageUV, vec4(accumulated, 1.0));
        } else {
            imageStore(accumulateImage, imageUV, vec4(result, 1.0));
            imageStore(image, imageUV, vec4(result, 1.0));
        }
    } else {
        // if the camera hasn't changed, then mix with previous results
        if (pushC.previousFrames > 0) {
            vec3 previous = imageLoad(image, imageUV).xyz;
            result = mix(previous, result, 1.0 / (pushC.previousFrames + 1));

            imageStore(image, imageUV, vec4(result, 1.0));
        } else {
            imageStore(image, imageUV, vec4(result, 1.0));
        }
    }

}