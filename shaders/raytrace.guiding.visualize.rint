#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "raycommon.glsl"
#include "guiding.visu.glsl"

//@formatter:off
layout(push_constant) uniform PushConstant{ pushConstant pushC; };

layout(binding = 15, set = 1, scalar) buffer Aabbs { aabb aabbs[]; };
//@formatter:on

// Checks for intersection with sphere at center of bounding box with PushConstant defined radius
void main()
{
    aabb bb = aabbs[gl_PrimitiveID];
    vec3 extent = bb.max - bb.min;
    float radius = min(extent.x, min(extent.y, extent.z)) * 0.5 * pushC.guidingVisuScale;

    // Center of AABB
    vec3 center;
    if (pushC.guidingVisuMove) {
        center = getVisuCenter(pushC.time, pushC.guidingVisuPhiScale, pushC.guidingVisuThetaScale, bb, radius);
    } else {
        center = bb.min + 0.5 * extent;
    }

    // Intersection
    vec3 oc = gl_WorldRayOriginEXT - center;
    float dotDOC = dot(gl_WorldRayDirectionEXT, oc);
    float rootTerm = dotDOC * dotDOC - dot(oc, oc) + radius * radius;

    if (rootTerm < 0) {
        return;
    }

    float root = sqrt(rootTerm);
    float t1 = - dotDOC + root;
    float t2 = - dotDOC - root;
    reportIntersectionEXT(t1, 0);
    reportIntersectionEXT(t2, 0);

}